// BigJoinDemo.cpp - Exploring big joins and memoized joins on tables with indexes using Kaldanes

// Please build for release to get good performance

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

  BigJoinDemo.cpp program

  Exploring big joins and memoized joins on tables with indexes using Kaldanes

  The OpenFlights.org Air Routes Database

  The database used was accessed from the database used by OpenFlights.org. The files contain
  data on all the air routes, airports, and airlines as of 2009, not maintained since. At that
  time there were 65,612 valid air routes (with valid source and destination airports, and
  airlines.) It’s a small database, only 3.5 MB, but you can do big joins on a small database.
  In reference to the relatively small size of database used in the demo programs, the argument
  for whether the current code base will scale to enormous size, has three parts: (1) the index
  sorts are linear time complexity relative to the count of rows while using a small PMNK index
  element, (2) the nested loop joins are linear time complexity relative to the number of output
  joined rows, and also linear relative to the number of range queries, which have an average
  2(log2(n)-1) time complexity for consistent databases, where n is the number of table rows,
  and (3) the memoized join time complexity is effectively constant time. If you think of the
  compile cost as including the memoized join cost, then compiling the relational database
  queries only occurs one time per generation of the database.

  At OpenFlights.org, the data is stored in .dat files, those were converted to .csv files by
  removing quoted strings and replacing commas in those quoted strings with semicolons to
  satisfy the limited .csv input functioning of the current code base. Everything is #-commented
  (R .csv style) in the resulting .csv files presented in the code base.

  The relations between the demo program tables are (1) many airlines serve many airports [m:m],
  (2) routes are flown by one airline + airlines serve many routes [1:m], and (3 and 4) routes
  have one source and destination airport + airports have many source routes [1:m] and many
  destination routes [1:m].
   __________________________________________________________________________________________
  |                                                                                          |
  |                           OpenFlights.org Air Routes Database                            |
  |     ________________                                               ________________      |
  |    |                |_                                           _|                |     |
  |    |                | \                                         / |                |     |
  |    |    Airlines    |----------------- serving [m:m] -------------|    Airports    |     |
  |    |                |_/                                         \_|                |     |
  |    |________________|                                             |________________|     |
  |            |                                                          |       |          |
  |            |                                                         /        |          |
  |            :                            .--- source [m:1] ----------'         |          |
  |             \                          /                                      |          |
  |              \                        /                                       |          |
  |             flying                   |                                        |          |
  |               [1:m]                 /|\                                       |          |
  |                 \            ______|_|_|______                                |          |
  |                  \         _|                 |_                              ;          |
  |                   \       / |                 | \                            /           |
  |                    `--------|     Routes      |------ destination [m:1] ----'            |
  |                           \_|                 |_/                                        |
  |                             |_________________|                                          |
  |                                                                                          |
  |                                                                                          |
  |__________________________________________________________________________________________|

  Once again, the BigJoinDemo program, as all the demo programs do, has two sections before the
  main() function: (1) a Static Metadata Section (SMS) laid out in an absolutely order critical
  way containing everything (classes, types, static data, const and constexpr) that is needed
  for generic programming (compile-time) of the relational database system, and (2) an Active
  Program Section (APS) laid out in whatever order that is desired, in this case containing
  performance analysis declarations and functions, data loading and printing functions, and a
  runtime checker to partially guarantee the consistency of columns versus tables in the layout
  in the SMS.

  All of the elements of the main() function, are executed within an anonymous exception
  handler, that prints out the ugly extended name of the exception with the readable name at the
  end, and that also works in release code for bug analysis during performance testing.

  BigJoinDemo keeps track of the time consumed by operations and printing those operations
  separately, using the nanosecond clock facility of C++11 on Linux. Initially it builds the
  database:

  1.    The three tables are allocated and loaded from .csv files and then anchored into RowString
        arrays.
  2.    Space for the ten indexes on those three tables is allocated.
  3.    The table source anchor is copied into the indexes, the index keys are copied into the
        indexes from the tables, and the indexes are sorted.

  At this point the database is up and ready to query: for the three relational database system
  demos (TableDemo, JoinDemo and BigJoinDemo,) the average time to produce the database and
  bring it up from scratch using input .csv files was 115.556 ms, less than 1/8th of a second.

  Since there are only 65,612 valid air routes in this database, simple queries on valid routes
  will not allow bigger results to test the performance at scale. However, what if the question
  is asked of the database, “How many double routes would there be if at the end of any flight
  on one of those 65,612 valid routes, the passenger hopped on any plane from any airline
  leaving that destination airport to go anywhere you could fly?”

  Those could called “double routes” where the destination airport of that route was linked as
  the source airport of any other route for any airline. This might be an interesting query for
  disease transmission, tracking criminal activity or missing persons, etc.

  Those QueryPlan class objects would have six RelationVector objects as template input types,
  of which one would be the same: the connection between a route table destination airport and
  the airport table row would occur twice. Hence five relation vectors are created for this
  double route join query that has six relations: (1) an airline flying some first routes, (2)
  some first routes relating to their first source airport, (3) some first routes relating to
  their first destination airport, (4) some first destination airports relating to second route
  source airports, (5: identical relation vector as 3, but different linkage) some second
  routes relating to their second destination airport and (6: inverse of 1) some second route
  airlines relating to an airline.

  Since the top-down query plan construction in constexpr void initJoin() mimics how nested
  loop joins are done by hand, the query optimizer gets this right for this query and probably
  for any bill-of-materials explosion on inventory tables and similar queries that conform to
  the nested loop join model. This will not automatically work for more exotic queries, and
  future refactoring the current demo code base will naturally enhance query optimization to
  handle more and more exotic cases. However, this should never be at the cost of performance
  and scale.

  BigJoinDemo has different subjects of inquiry from JoinDemo, which looked at the top ten
  passenger carriers.  This demo looks at a relatively even trend of air carriers from American
  Airlines at the top, to the tiny air carriers that only fly a few routes. In addition to the
  two types of queries run in JoinDemo: the full nested loop join and the full memoized join
  producing the same array as the nested loop join for fast memoized queries, a third query
  only accessing the range on the memoized joined row array is done. This is because that
  memoized array, which is ordered by the from-index of airline provides the same sequential
  access to ordered result data as do the output joined row arrays from the first two queries,
  without moving the array data to another location. When the result data is small, this does
  not matter, but in the case of American Airlines there are 564,538 double routes in almost
  16MB of data being moved. Since that data move only gains you a difference in location and
  not in access speed, it is truly unnecessary and is quite costly for bigger result sets.

  The third double route query without the move is the fastest, with the identical result to
  the other two. The performance results are on the graph at the beginning of this document: a
  constant time of some microseconds for joins, of any number of tables (C++ compiler limited,)
  for tables of any size (memory and operating system limited,) with mmapped relational
  database slabs sharable across nodes in a datacenter at the hardware limit of data access.

  It took 9.094 seconds to do the full nested loop join to create the memoized joined row array
  for all possible double routes (10,925,455) in the database, and to allow those memoized
  joins to take two microseconds and make relational database joins effectively free of cost.
  Note that the correlation is still one microsecond per resulting output memoized join array
  element even at that scale. The time spent compiling the relational database into memoized
  joins by producers will dwarf the time spent compiling the C++ code for them, but it is time
  well spent and energy and cooling costs saved.

  Triple routes would most likely number around 2 billion, and that could further make the
  scalability case, but the picture at the front of this white paper makes the case
  sufficiently, since each query on the triple route memoized join result would still only cost
  one range query [at an average of 2(log2(n)-1)), where n is 2G array, instead of a 10M array]
  to access as well.

*/

#include <iostream>
#include <fstream>
#include <climits>
#include <iostream>
#include <stddef.h>
#include <algorithm>
#include <cstring>
#include <tuple>
#include <chrono>
#include <climits>
#include <typeinfo>

#ifdef __GNUG__
#include <cxxabi.h> // gcc only: fetching type names
#endif // __GNUG__

#define NAME_OF(variable) ((void)variable, #variable)

static const bool debugTrace = false;

using namespace std;
using namespace std::chrono;

// Banners from: http://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=Section
// Using ANSI Shadow font

/*
███████╗      ███╗   ███╗        ███████╗
██╔════╝      ████╗ ████║        ██╔════╝
███████╗      ██╔████╔██║        ███████╗
╚════██║      ██║╚██╔╝██║        ╚════██║
███████║tatic ██║ ╚═╝ ██║etadata ███████║ection
╚══════╝      ╚═╝     ╚═╝        ╚══════╝

Goal: What would reside in a database catalog and execute at runtime (compiler, optimizer, etc.)
instead lives in type space and executes at compile time.

Everything in this section (classes, types, static data, const and constexpr)
is needed for generic programming (compile-time)

*/

template<typename T>
void displayNameOfType(T elem)
{
    string typeName = typeid(T).name();

#ifdef __GNUG__
    int status = 0;
    char *readableName = abi::__cxa_demangle(typeName.c_str(), NULL, NULL, &status);
    if (status == 0)
    {
        typeName = readableName;
        std::free(readableName);
    }
#endif // __GNUG__

    cout << typeName;
}

// Order is critical ...

// Needed to reinterpret_cast later
static const std::size_t maxColumnSizeDefault = 1024;
static const std::size_t pmnkSizeDefault = 7;

enum class Table
{
    airports,
    airlines,
    routes,

    table_Count,
    nilTable = INT_MIN
};
// insert new tables before table_Count, please

static char* charRowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static void* rowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static std::size_t rowCounts[(int)Table::table_Count] = {0}; // ditto, and index length = table length.

enum class Column // must be in the order of Table, above
{
    // 14 airports table columns
    airportId,
    airportName,
    airportCity,
    airportCountry,
    airportIATA,
    airportICAO,
    airportLatitude,
    airportLongitude,
    airportAltitude,
    airportTimezone,
    airportDST,
    airportTz,
    airportType,
    airportSource,

    airportsDivider,

    // 8 airlines table columns
    airlineId,
    airlineName,
    airlineAlias,
    airlineIATA,
    airlineICAO,
    airlineCallsign,
    airlineCountry,
    airlineActive,

    airlinesDivider,

    // 9 routes table columns
    routeAirline,
    routeAirlineId,
    routeSourceAirport,
    routeSourceAirportId,
    routeDestinationAirport,
    routeDestinationAirportId,
    routeCodeshare,
    routeStops,
    routeEquipment,

    routesDivider,

    columnCount, // accessing the array with this enum's static should segfault
    nilColumn = INT_MIN // accessing the array with this enum's static should segfault
};
// insert new columns in order before columnCount,
// please, then adjust the table of IDs below

// Index metadata resides in these (3) arrays
static char* charIndexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static void* indexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static std::size_t indexCounts[(int)Column::columnCount] = {0}; // ditto, and index length = table length.

typedef std::size_t OffsetValue;
static const OffsetValue trammel = UINT_MAX; // to catch the alignment bugs
static const OffsetValue columnId[(int)Column::columnCount + 2] =
// This array translates from the Column enum to the column ID in the specific table.
// THEY NEED TO BE MAINTAINED IN ALIGNMENT!
// "It must be mounted on a tripod!": see "The Wild Bunch" by Peckinpah (director's cut)
// It is effectively the database catalog metadata.
// Use the assertion checker below
// Sorry, this is the only thing I couldn't automate easily and reliably! Variadic templates, later?
{
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,trammel,// 14 valid airports column IDs

    0,1,2,3,4,5,6,7,trammel,// 8 valid airlines column IDs

    0,1,2,3,4,5,6,7,8,trammel,// 9 valid routes column IDs

    trammel,trammel // Everything accessing a trammel as an index should segfault
};

class Improperly_Maintained_columnId_Table : public runtime_error
{
public:
    Improperly_Maintained_columnId_Table() :
        runtime_error("the columnId table relationship to Column enums is broken") {}
};

void columnIdChecker()
{
    if (columnId[(int)Column::airportsDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::airlinesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::routesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
}

class Invalid_Column_Enum_Class_Member : public runtime_error
{
public:
    Invalid_Column_Enum_Class_Member() :
        runtime_error("the Column enum class element is not a valid member") {}
};

// Had the above gone well this will work fine
constexpr Table column2Table(Column columnEnum)
{
    return (columnEnum < Column::airportsDivider) ? Table::airports
           : (columnEnum < Column::airlinesDivider) ? Table::airlines
           : (columnEnum < Column::routesDivider) ? Table::routes
           : Table::nilTable;
}

#include "RowString.h"
#include "IndexString.h"

const std::size_t airportsMaxLen = 186, airportsColumns = 14, airportsCount = 7184;
const char airportsFile[] = "./airports.csv";
typedef RowString<char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault> airportRow;

const std::size_t airlinesMaxLen = 404, airlinesColumns = 8, airlinesCount = 6162;
const char airlinesFile[] = "./airlines.csv";
typedef RowString<char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault> airlineRow;

const std::size_t routesMaxLen = 65, routesColumns = 9, routesCount = 67663;
const char routesFile[] = "./routes.csv";
typedef RowString<char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault> routeRow;

// Compile time (static) programming is difficult in c++11
template<Column columnEnum>
constexpr decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                   : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                   : (columnEnum < Column::routesDivider) ? (routeRow*)0
                   : (void*)0) column2RowStringPtr()
{
    return (decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                     : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                     : (columnEnum < Column::routesDivider) ? (routeRow*)0
                     : (void*)0)) (columnEnum < Column::airportsDivider) ? reinterpret_cast<airportRow*>(rowAnchors[(std::size_t)Table::airports])
           : (columnEnum < Column::airlinesDivider) ? reinterpret_cast<airlineRow*>(rowAnchors[(std::size_t)Table::airlines])
           : (columnEnum < Column::routesDivider) ? reinterpret_cast<routeRow*>(rowAnchors[(std::size_t)Table::routes])
           : (void*)0;
}

typedef IndexString<Column::airportId, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportIdType;
typedef IndexString<Column::airportName, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportNameType;
typedef IndexString<Column::airportCountry, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportCountryType;
typedef IndexString<Column::airportIATA, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportIATAType;
typedef IndexString<Column::airportICAO, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportICAOType;
typedef IndexString<Column::airlineId, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault> airlineIdType;
typedef IndexString<Column::airlineCountry, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault> airlineCountryType;
typedef IndexString<Column::routeAirlineId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeAirlineIdType;
typedef IndexString<Column::routeSourceAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeSourceAirportIdType;
typedef IndexString<Column::routeDestinationAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeDestinationAirportIdType;

#include "RelationVector.h"

// routes join relations
typedef RelationVector<airlineIdType, routeAirlineIdType> airlineId2RouteAirlineIdType;
typedef RelationVector<routeSourceAirportIdType, airportIdType> routeSourceAirportId2AirportIdType;
typedef RelationVector<routeDestinationAirportIdType, airportIdType> routeDestinationAirportId2AirportIdType;
// double routes join relations
typedef RelationVector<routeDestinationAirportIdType, routeSourceAirportIdType> routeDestinationAirportId2RouteSourceAirportIdType;
typedef RelationVector<routeAirlineIdType, airlineIdType> routeAirlineId2AirlineIdType;

typedef tuple<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType, routeDestinationAirportId2RouteSourceAirportIdType, routeAirlineId2AirlineIdType, routeDestinationAirportId2AirportIdType> doubleRoutesJoinRelationsTupleType;
doubleRoutesJoinRelationsTupleType relVecsTuple;

#include "JoinedRow.h"
typedef QueryPlan<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType, routeDestinationAirportId2RouteSourceAirportIdType, routeAirlineId2AirlineIdType, routeDestinationAirportId2AirportIdType> doubleRoutesQueryPlanType;
typedef JoinedRow<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType, routeDestinationAirportId2RouteSourceAirportIdType, routeAirlineId2AirlineIdType, routeDestinationAirportId2AirportIdType> doubleRoutesJoinedRowType;


/*
 █████╗       ██████╗   ███████╗
██╔══██╗      ██╔══██╗  ██╔════╝
███████║      ██████╔╝  ███████╗
██╔══██║      ██╔═══╝   ╚════██║
██║  ██║ctive ██║rogram ███████║ection
╚═╝  ╚═╝      ╚═╝       ╚══════╝

Nothing in this section has definitions that the generic programming (compile-time) requires.

*/

// Statistics
duration<double, nano> runTime;
duration<double, nano> testTime;
duration<double, nano> standardJoinTime;
duration<double, nano> memoizedJoinTime;
duration<double, nano> rangeQueryTime;
duration<double, nano> totalTime;
double rangeQueriesStart;

void resetStats()
{
    testTime = duration<double, nano> (0);
    standardJoinTime = duration<double, nano> (0);
    memoizedJoinTime = duration<double, nano> (0);
    totalTime = duration<double, nano> (0);
    rangeQueries = 0;
    rangeQueriesStart = 0;
}

void displayTime(const char text[])
{
    cout.precision(3);
    cout << "Time for " << text << " = " << fixed << chrono::duration <double, micro> (testTime).count() << " microseconds." << endl;
}

void displayTime(const char text[], duration<double, nano> time)
{
    cout.precision(3);
    cout << "Time for " << text << " = " << fixed << chrono::duration <double, micro> (time).count() << " microseconds." << endl;
}

void displayRangeQueries()
{
    int queries = rangeQueries - rangeQueriesStart;
    cout.precision(0);
    cout << "Using " << fixed << queries << ((queries == 1) ? " range query." : " range queries.") << endl;
}

void displayStats()
{
    cout << std::string(80, '_') << endl << endl;
    cout << "Statistics for the run of the program, including:" << endl;
    cout << "   1. Allocating and loading three tables from CSV files on disk, around 80K rows." << endl;
    cout << "   2. Allocating, copying the keys and sorting ten indexes on those three tables." << endl;
    cout << "   3. Creating six relation vectors, each containing a from-index and a to-index." << endl;
    cout << "   4. Creating a tuple from those six relation vectors to store the query objects." << endl;
    cout << "   5. Creating and optimizing a database seven-table double-route join query plan for those six relation vectors." << endl;
    cout << "   6. Creating a joined row output array and doing ten nested loop join queries into it for the double-routes of the ten lowest-to-highest route carriers." << endl;
    cout << "   7. Doing a full memoized loop join double-route query for all airlines into the joined row output array." << endl;
    cout << "   8. Doing ten memoized join double-route queries into arrays for the ten lowest-to-highest route carriers (apples to apples comparison.)" << endl;
    cout << "   9. Doing ten memoized join double-route queries for the ten lowest-to-highest route carriers (apples to oranges comparison.)" << endl << endl;
    cout.precision(5);
    cout << "Total run time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> (runTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total relational database system time spent in main() procedure thus far, including I/O = "
         << fixed << chrono::duration <double, micro> (totalTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total display output time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> ((runTime - totalTime)/1000000).count() << " seconds" << endl;
    cout << std::string(80, '_') << endl << endl;
}

class Boolian_Error : public runtime_error
{
public:
    Boolian_Error() :
        runtime_error("boolian operator failure") {}
};

class Could_Not_Open_File : public runtime_error
{
public:
    Could_Not_Open_File() :
        runtime_error("file name could not be opened") {}
};

class Range_Query_Consistency_Failure : public runtime_error
{
public:
    Range_Query_Consistency_Failure() :
        runtime_error("if range low is found, same key range high must also be.") {}
};

class Array_Not_Sorted : public runtime_error
{
public:
    Array_Not_Sorted() :
        runtime_error("Array items are not in sorted order") {}
};

class Output_Array_Size_Not_Big_Enough : public runtime_error
{
public:
    Output_Array_Size_Not_Big_Enough() :
        runtime_error("Array size not big enough for output: more JoinedRows than space") {}
};

template<typename T>
void throwExceptionIfUnsorted(T arr[], int size)
{
    for (int i = 1; i < size - 1; ++i)
    {
        if (arr[i - 1] > arr[i])
        {
            throw Array_Not_Sorted();
        }
    }
    return;
}

template<typename T>
void loadCSVFile(T arr[], int size, const char filename[])
{
    ifstream csvFile(filename);
    if (!csvFile)
    {
        throw Could_Not_Open_File();
    }
    for (int i = 0; (csvFile) && i <= size; i++)
    {
        char input;
        csvFile >> input;
        if (input == '#') // pass over R Language comment lines beginning with a '#'
        {
            csvFile.ignore(numeric_limits<streamsize>::max(), '\n');
            i--;
        }
        else
        {
            csvFile.putback(input);
            csvFile >> arr[i];
        }
    }
    csvFile.close();
}

class Type_Not_Supported_Here : public runtime_error
{
public:
    Type_Not_Supported_Here() :
        runtime_error("that type is not supported in this function") {}
};

template<typename T>
void printIndex(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++) cout << *(arr[i].row()) << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printTable(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isRowString[] = "RowString";
    if (strstr(typeName.c_str(), isRowString))
    {
        for (int i = 0; i < size; i++) cout << arr[i] << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printJoin(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isJoinedRow[] = "JoinedRow";
    if (strstr(typeName.c_str(), isJoinedRow))
    {
        for (int i = 0; i < size; i++)
        {
            cout << std::string(133, '-') << endl;
            arr[i].print();
        }
        cout << std::string(133, '-') << endl << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printIndexColumn(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++)
        {
            cout << arr[i] << endl;
//            cout << arr[i];
//            if (i + 1 < size) cout << " ";
//            else cout << endl;
        }
    }
    else throw Type_Not_Supported_Here();
}

void asserts()
{
    columnIdChecker();
}

class Logic_Error : public runtime_error
{
public:
    Logic_Error() :
        runtime_error("something terribly wrong if you can't allocate an array.") {}
};

int main()
{
    cout << endl << endl << "[Note: Remember to set the C++11 switch in the IDE or compiler!" << endl << endl
         << " Remember to use release builds if you are analyzing performance," << endl
         << "   otherwise Index builds will be very slow!" << endl << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited," <<endl
         << "   otherwise it can die!]" << endl;

    //airports, airlines, routes
    try
    {
        // Anonyomous catch -> exception names in release code execution

        asserts();

        high_resolution_clock::time_point runStart = high_resolution_clock::now();

        // Tables
        high_resolution_clock::time_point start = high_resolution_clock::now();

        airportRow airports[airportsCount];
        airports[0].dropAnchor(airports, airportsCount);
        loadCSVFile(airports, airportsCount, airportsFile);

        airlineRow airlines[airlinesCount];
        airlines[0].dropAnchor(airlines, airlinesCount);
        loadCSVFile(airlines, airlinesCount, airlinesFile);

        routeRow routes[routesCount];
        routes[0].dropAnchor(routes, routesCount);
        loadCSVFile(routes, routesCount, routesFile);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        cout << endl << endl;
        displayTime("space allocating and loading the three tables from CSV files");

        // Index space allocation
        start = high_resolution_clock::now();

        airportIdType airportsId[airportsCount];
        airportNameType airportsName[airportsCount];
        airportCountryType airportsCountry[airportsCount];
        airportIATAType airportsIATA[airportsCount];
        airportICAOType airportsICAO[airportsCount];
        airlineIdType airlinesId[airlinesCount];
        airlineCountryType airlinesCountry[airlinesCount];
        routeAirlineIdType routesAirlineId[routesCount];
        routeSourceAirportIdType routesSourceAirportId[routesCount];
        routeDestinationAirportIdType routesDestinationAirportId[routesCount];

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("space allocating the ten indexes");

        // Building the indexes
        start = high_resolution_clock::now();

        airportsId[airportsCount].dropAnchorCopyKeysSortIndex(airportsId, airportsCount);
        airportsName[airportsCount].dropAnchorCopyKeysSortIndex(airportsName, airportsCount);
        airportsCountry[airportsCount].dropAnchorCopyKeysSortIndex(airportsCountry, airportsCount);
        airportsIATA[airportsCount].dropAnchorCopyKeysSortIndex(airportsIATA, airportsCount);
        airportsICAO[airportsCount].dropAnchorCopyKeysSortIndex(airportsICAO, airportsCount);
        airlinesId[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesId, airlinesCount);
        airlinesCountry[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesCountry, airlinesCount);
        routesAirlineId[routesCount].dropAnchorCopyKeysSortIndex(routesAirlineId, routesCount);
        routesSourceAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesSourceAirportId, routesCount);
        routesDestinationAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesDestinationAirportId, routesCount);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("copying the keys and sorting the ten indexes");
        testTime /= 10;
        displayTime("each index on the average");

        // Creating the relations
        start = high_resolution_clock::now();

        airlineId2RouteAirlineIdType airlineId2RouteAirlineId;
        routeSourceAirportId2AirportIdType routeSourceAirportId2AirportId;
        routeDestinationAirportId2AirportIdType routeDestinationAirportId2AirportId;
        routeDestinationAirportId2RouteSourceAirportIdType routeDestinationAirportId2RouteSourceAirportId;
        routeAirlineId2AirlineIdType routeAirlineId2AirlineId;

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the six relation vectors");

        // Creating the relation vector tuple
        start = high_resolution_clock::now();

        doubleRoutesJoinRelationsTupleType doubleRoutesJoinRelationsTuple(airlineId2RouteAirlineId, routeSourceAirportId2AirportId, routeDestinationAirportId2AirportId, routeDestinationAirportId2RouteSourceAirportId, routeAirlineId2AirlineId, routeDestinationAirportId2AirportId);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the tuple containing the six relation vectors");

        // Creating the query plan
        start = high_resolution_clock::now();

        doubleRoutesQueryPlanType routesQueryPlan(airlineId2RouteAirlineId, routeSourceAirportId2AirportId, routeDestinationAirportId2AirportId, routeDestinationAirportId2RouteSourceAirportId, routeAirlineId2AirlineId, routeDestinationAirportId2AirportId);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the query plan to join the six relation vectors");

        // Creating the joined row array for join output
        start = high_resolution_clock::now();

        const std::size_t doubleRoutesJoinedRowCount = 11000000;
        doubleRoutesJoinedRowType doubleRoutesJoinedRow[doubleRoutesJoinedRowCount];
        doubleRoutesJoinedRow[0].dropAnchor(&routesQueryPlan);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the joined row array to contain the join output");

        cout << std::string(80, '_') << endl << endl;
        cout << "First, we do ten standard seven-table join queries listing the valid double routes (routes possessing valid airlines, from and to airports ... linking to a second route from the first destination airport on to any second airport on any airline) for the ten lowest-to-highest route carriers to show the effects of scale." << endl << endl;

        int standardTotalRoutes = 0;
        double standardRangeQueries = 0;

        // Lambda for standard joins
        auto doStandardJoin = [&] (char selectTerm[], char displayText[], bool print=false)
        {
            start = high_resolution_clock::now();
            rangeQueriesStart = rangeQueries;
            int retVal;
            if (!routesQueryPlan.startJoin(selectTerm))
                cout << "Couldn't initialize the validated query for " << displayText << "." << endl << endl;
            else
            {
                retVal = doubleRoutesJoinedRow[0].join(doubleRoutesJoinedRowCount);
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                standardJoinTime += testTime;
                totalTime += testTime;
                displayTime(displayText);
                displayRangeQueries();
                standardRangeQueries += rangeQueries - rangeQueriesStart;
                if (retVal >= 0)
                {
                    cout << "Reporting " << retVal << " valid double air routes." << endl << endl;
                    standardTotalRoutes += retVal;
                    if (print) printJoin(doubleRoutesJoinedRow, retVal);
                }
                else
                    cout << "Array size not big enough for " << displayText
                         << " output: more JoinedRows than " << -retVal << endl << endl;
            }
        };

        doStandardJoin((char*)"109", (char*)" Alaska Central Express join query");
        doStandardJoin((char*)"9784", (char*)"Yangon Airways join query");
        doStandardJoin((char*)"426", (char*)"Air Armenia join query");
        doStandardJoin((char*)"338", (char*)"Airnorth join query");
        doStandardJoin((char*)"9828", (char*)"Ciel Canadien join query");
        doStandardJoin((char*)"4897", (char*)"Thomas Cook Airlines join query");
        doStandardJoin((char*)"3290", (char*)"Lion Mentari Airlines join query");
        doStandardJoin((char*)"4319", (char*)"Scandinavian Airlines System join query");
        doStandardJoin((char*)"137", (char*)"Air France join query");
	doStandardJoin((char*)"24", (char*)"American Airlines join query");
	cout << "Total valid double air routes count for the ten lowest-to-highest route carriers = "
             << standardTotalRoutes << "." << endl;

        displayTime("all ten standard join queries, in total", standardJoinTime);
        cout.precision(0);
        cout << "Using a total of " << standardRangeQueries << " range queries." << endl;

        cout << std::string(80, '_') << endl << endl;
        cout << "Second, we create a full memoized seven-table join of all the valid double routes for each airline in very compact form." << endl << endl;

        // create full memoized join for all routes on all airlines
        start = high_resolution_clock::now();
        rangeQueriesStart = rangeQueries;
        int actualJoinCount;
        if (!routesQueryPlan.startFullMemoizedJoin())
            cout << "Couldn't initialize the validated query." << endl << endl;
        else
        {
            actualJoinCount = doubleRoutesJoinedRow[0].join(doubleRoutesJoinedRowCount);
            if (actualJoinCount < 0) throw Output_Array_Size_Not_Big_Enough();
            mergeSortInvoke(doubleRoutesJoinedRow, actualJoinCount); // faster than quick sort for these ...
            testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
            totalTime += testTime;
            displayTime("full memoized join creation");
            displayRangeQueries();
            if (actualJoinCount >= 0)
            {
                cout << "Full memoized join: valid routes count for all airlines = " << actualJoinCount << endl << endl;
                //printJoin(doubleRoutesJoinedRow, actualJoinCount);
            }
            else
                cout << "Memoized join array size not big enough for output: more JoinedRows than "
                     << abs(actualJoinCount) << endl << endl;
        }

        cout << std::string(80, '_') << endl << endl;
        cout << "Third, we use that full memoized join to do ten memoized seven-table join queries listing the valid double routes for the ten lowest-to-highest route carriers to show the effects of scale, including the cost of moving the bytes although we don't need to (it's only for an apples to apples comparison.) Note that the numbers of double routes are the same as the nested loop joins, but take orders of magnitude less time, and only one range query for each." << endl << endl;

        int memoizedTotalRoutes = 0;
        double memoizedRangeQueries = 0;
        memoizedJoinTime = duration<double, nano> (0);

        // Lambda for memoized joins
        auto doMemoizedJoin = [&] (char selectTerm[], char displayText[], bool print=false)
        {
            start = high_resolution_clock::now();
            rangeQueriesStart = rangeQueries;
            int rangeLow = binarySearchRangeLow(doubleRoutesJoinedRow, actualJoinCount, selectTerm);
            if (rangeLow < 0)
                cout << "No valid double air routes for " << displayText << "." << endl << endl;
            else
            {
                int rangeHigh = binarySearchRangeHigh(doubleRoutesJoinedRow, actualJoinCount, selectTerm);
                if (rangeHigh < 0) throw Range_Query_Consistency_Failure();
                int arraySize = rangeHigh - rangeLow + 1;
                doubleRoutesJoinedRowType outputJoinedRows[arraySize];
                outputJoinedRows[0].dropAnchor(&routesQueryPlan);
                int j = 0;
                for (int i = rangeLow; i <= rangeHigh; i++) outputJoinedRows[j++] = doubleRoutesJoinedRow[i];
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                memoizedJoinTime += testTime;
                totalTime += testTime;
                displayTime(displayText);
                displayRangeQueries();
                memoizedRangeQueries += rangeQueries - rangeQueriesStart;
                if (arraySize >= 0)
                {
                    cout << "Reporting " << arraySize << " valid double air routes." << endl << endl;
                    memoizedTotalRoutes += arraySize;
                    if (print) printJoin(outputJoinedRows, arraySize);
                }
                else throw Logic_Error();
            }
        };

        doMemoizedJoin((char*)"109", (char*)" Alaska Central Express join query");
        doMemoizedJoin((char*)"9784", (char*)"Yangon Airways join query");
        doMemoizedJoin((char*)"426", (char*)"Air Armenia join query");
        doMemoizedJoin((char*)"338", (char*)"Airnorth join query");
        doMemoizedJoin((char*)"9828", (char*)"Ciel Canadien join query");
        doMemoizedJoin((char*)"4897", (char*)"Thomas Cook Airlines join query");
        doMemoizedJoin((char*)"3290", (char*)"Lion Mentari Airlines join query");
        doMemoizedJoin((char*)"4319", (char*)"Scandinavian Airlines System join query");
        doMemoizedJoin((char*)"137", (char*)"Air France join query");
	doMemoizedJoin((char*)"24", (char*)"American Airlines join query");
 	cout << "Total valid double air routes count for the ten lowest-to-highest route carriers = "
             << memoizedTotalRoutes << "." << endl;

        displayTime("all ten memoized join queries, in total", memoizedJoinTime);
        cout.precision(0);
        cout << "Using a total of " << memoizedRangeQueries << " range queries." << endl << endl;

        cout << std::string(80, '_') << endl << endl;
        cout << "Fourth, let's execute a range query boundary lambda from the airlineId index, for all double routes from each airline using the memoized join, to find out the average cost of getting the low and high range query boundaries." << endl << endl;

        int rangeLowRowIndex;

        start = high_resolution_clock::now();
        rangeQueriesStart = rangeQueries;

        for (int i = 0; i < (int)airlinesCount; i++)
        {
            rangeLowRowIndex = binarySearchRangeLow(doubleRoutesJoinedRow, actualJoinCount, airlinesId[i].c_str());
            if (rangeLowRowIndex >= 0)
                if (binarySearchRangeHigh(doubleRoutesJoinedRow, actualJoinCount, airlinesId[i].c_str()) < 0)
                    throw Range_Query_Consistency_Failure();
        };

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        rangeQueryTime += testTime;
        totalTime += testTime;
        displayTime("determining all airlines range query boundaries (not touching the rows) on the routes table");
        cout.precision(0);
        cout << "Using a total of " << rangeQueries - rangeQueriesStart << " range queries (number of airlines.)" << endl;
        cout.precision(3);
        cout << "Yielding an average time of "
             << fixed << chrono::duration <double, micro> (rangeQueryTime / (rangeQueries - rangeQueriesStart)).count()
             << " microseconds to find one range query boundary pair." << endl << endl;

        cout << std::string(80, '_') << endl << endl;
        cout << "Finally, we use that full memoized join to do ten memoized seven-table join queries listing the valid double routes for the ten lowest-to-highest route carriers to show the effects of scale: however, without the unnecessary byte moves (this is an apples to oranges comparison, but you can access the bytes from the memoized join and don't need to output them.) Note that the numbers of these double routes are the same as the nested loop joins, but take effectively constant time in comparison, and only one range query for each. We do two runs for comparison, because the measurement is so small that the second run is different in an interesting way." << endl << endl;



        // Lambda for memoized joins
        auto doMemoizedJoinNoMoves = [&] (char selectTerm[], char displayText[], bool print=false)
        {
            start = high_resolution_clock::now();
            rangeQueriesStart = rangeQueries;
            int rangeLow = binarySearchRangeLow(doubleRoutesJoinedRow, actualJoinCount, selectTerm);
            if (rangeLow < 0)
                cout << "No valid double air routes for " << displayText << "." << endl << endl;
            else
            {
                int rangeHigh = binarySearchRangeHigh(doubleRoutesJoinedRow, actualJoinCount, selectTerm);
                if (rangeHigh < 0) throw Range_Query_Consistency_Failure();
                int arraySize = rangeHigh - rangeLow + 1;
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                memoizedJoinTime += testTime;
                totalTime += testTime;
                displayTime(displayText);
                displayRangeQueries();
                memoizedRangeQueries += rangeQueries - rangeQueriesStart;
                if (arraySize >= 0)
                {
                    cout << "Reporting " << arraySize << " valid double air routes." << endl << endl;
                    memoizedTotalRoutes += arraySize;
                    if (print) printJoin(doubleRoutesJoinedRow + rangeLow, arraySize);
                }
                else throw Logic_Error();
            }
        };

        cout << std::string(80, '_') << endl << endl;
	cout << "First run." << endl << endl;

        memoizedTotalRoutes = 0;
        memoizedRangeQueries = 0;
        memoizedJoinTime = duration<double, nano> (0);

        doMemoizedJoinNoMoves((char*)"109", (char*)" Alaska Central Express join query");
        doMemoizedJoinNoMoves((char*)"9784", (char*)"Yangon Airways join query");
        doMemoizedJoinNoMoves((char*)"426", (char*)"Air Armenia join query");
        doMemoizedJoinNoMoves((char*)"338", (char*)"Airnorth join query");
        doMemoizedJoinNoMoves((char*)"9828", (char*)"Ciel Canadien join query");
        doMemoizedJoinNoMoves((char*)"4897", (char*)"Thomas Cook Airlines join query");
        doMemoizedJoinNoMoves((char*)"3290", (char*)"Lion Mentari Airlines join query");
        doMemoizedJoinNoMoves((char*)"4319", (char*)"Scandinavian Airlines System join query");
        doMemoizedJoinNoMoves((char*)"137", (char*)"Air France join query");
	doMemoizedJoinNoMoves((char*)"24", (char*)"American Airlines join query");
        cout << "Total valid double air routes count for the ten lowest-to-highest route carriers = "
             << memoizedTotalRoutes << "." << endl;

        displayTime("all ten memoized join queries, in total", memoizedJoinTime);
        cout.precision(0);
        cout << "Using a total of " << memoizedRangeQueries << " range queries." << endl << endl;

        cout << std::string(80, '_') << endl << endl;
	cout << "Second run." << endl << endl;

        memoizedTotalRoutes = 0;
        memoizedRangeQueries = 0;
        memoizedJoinTime = duration<double, nano> (0);

        doMemoizedJoinNoMoves((char*)"109", (char*)" Alaska Central Express join query");
        doMemoizedJoinNoMoves((char*)"9784", (char*)"Yangon Airways join query");
        doMemoizedJoinNoMoves((char*)"426", (char*)"Air Armenia join query");
        doMemoizedJoinNoMoves((char*)"338", (char*)"Airnorth join query");
        doMemoizedJoinNoMoves((char*)"9828", (char*)"Ciel Canadien join query");
        doMemoizedJoinNoMoves((char*)"4897", (char*)"Thomas Cook Airlines join query");
        doMemoizedJoinNoMoves((char*)"3290", (char*)"Lion Mentari Airlines join query");
        doMemoizedJoinNoMoves((char*)"4319", (char*)"Scandinavian Airlines System join query");
        doMemoizedJoinNoMoves((char*)"137", (char*)"Air France join query");
	doMemoizedJoinNoMoves((char*)"24", (char*)"American Airlines join query");
        cout << "Total valid double air routes count for the ten lowest-to-highest route carriers = "
             << memoizedTotalRoutes << "." << endl;

        displayTime("all ten memoized join queries, in total", memoizedJoinTime);
        cout.precision(0);
        cout << "Using a total of " << memoizedRangeQueries << " range queries." << endl << endl;



	runTime = duration_cast<duration<double>> (high_resolution_clock::now() - runStart);
        displayStats();

    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl; // the exception name is at the end of the long error string
    }
    return 0;
}

