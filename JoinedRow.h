#ifndef JOINEDROW_H
#define JOINEDROW_H

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

JoinedRow.h - header file for two classes: QueryPlan and JoinedRow

  QueryPlan Class

  A heavyweight relational QueryPlan class is defined by a variadic template parameter pack of
  ordered RelationVector class objects and creates a shared tuple of them

  The strategy for the QueryPlan class was that it would bear the burden of future metadata and
  join query initialization and processing required by the extremely lightweight JoinedRow class.
  In the current code base that burden is middling, but that will grow as more features are
  added. Of course that meant it had to precede the JoinedRow class in the declaration order, and
  yet be deeply coupled to it by a lot of machinery. So, both classes are located in the same
  header JoinedRow.h in the obvious order and share static globals for the handovers back and
  forth.

  Variadic Class Template Parameter Pack Compile-Time Recursion

  For a host of reasons: the need for true static polymorphism at scale, the complexity and C++11
  deficiency of handling for templates with optional parameters, problems with the C++ optimizer
  in complex variadic recursion, the necessity of using static globals, the problems of using
  constexpr in a template class with template static data, and more … it was decided that the
  only stable way that would scale to deeper recursion in the compiler, was to use the SFINAE
  termination method of recursion.

  It was also found that declaring local variables inside deeper levels of recursion made the
  compiler perform in an unstable manner, e.g., if you declare a local variable inside a
  recursion on a sufficiently complex variadic template parameter pack and don’t immediately use
  it, the compiler spins madly spitting out recursion context messages and then does not produce
  the compiler warning on the unused variable. An error or warning without a message can be quite
  difficult to diagnose!

  Add to that the fact that you cannot use the debugger or even print statements when the code
  doesn’t compile for an unknown reason. Sad to say, even when generic programming code compiles,
  when it doesn’t work the way it should, you cannot really debug the code that is executing in
  recursion in the compiler, what you get is a debug session emulating the runtime aspects of
  that. And print statements come out in strange orders from ostream in generic recursion
  recursive routines, and it seems impossible to rectify that disorder.

  Hence, the usage of an array of frame structures holding indexed locals at each level of
  recursion is a necessity: and then the strategy is to resuscitate an archaic driver technique.
  Then the problem arises, how deep are you in the recursion?

  This is solved by using the two layers of parameter packs, the template class parameter pack
  template<typename... classPack> and the pair of template parameters on the recursion procedure
  template<typename packFirst, typename... packRemaining>. Here’s a code snippet for discussion:
   _________________________________________________________________________________________________
  |                                                                                                 |
  | template<typename... packRemaining>                                                             |
  | constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type join() {}                |
  |                                                                                                 |
  | template<typename packFirst, typename... packRemaining>                                         |
  | void join()                                                                                     |
  | {                                                                                               |
  |             const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;   |
  |             const std::size_t maxPackDepth = sizeof...(classPack) - 1;                          |
  |             if (debugTrace) cout << endl << "join() packDepth = " << packDepth << endl << endl; |
  |                                                                                                 |
  |             // these are compile-time only, no runtime cost                                     |
  |             typedef decltype(((packFirst*)0)->r.from) fromType;                                 |
  |             const Column fromColumn = ((fromType)0)->enumColumn();                              |
  |             typedef decltype(((packFirst*)0)->r.to) toType;                                     |
  |                                                                                                 |
  |             if (packDepth == 0) arrayOffset = 0;                                                |
  |                                                                                                 |
  |             if (packDepth > maxPackDepth)                                                       |
  |                     throw Variadic_Parameter_Pack_Logic_Failed();                               |
  |                     // constants are seriously out of whack.                                    |
  |             else                                                                                |
  |             {                                                                                   |
  |                     if (!frame[packDepth].initialized) throw Initialization_Failure();          |
  |_________________________________________________________________________________________________|
		
  The value packDepth is a constant calculated from the constant size of classPack (a set of
  RelationVector types) by subtracting the constant size of packRemaining, which is greater as
  the compiler recurses deeper. At runtime you can think of this recursion as an array of
  constants generated during the compile with the constant packDepth as the depth gauge.

  Similarly the section of declarations below that line are all constants which vary at different
  levels as the packFirst element of the parameter pack of types from classPack get peeled away
  one by one until packRemaining has zero value. Even though the RelationVector pointers for
  packFirst, fromType and toType are being typecast onto zero values, the decltype for the first
  and constexpr member functions used in the others are still const: although these look like
  variables, they’re not. Additionally, column2Table is a constexpr function converting enum
  class values into other enum class values, which are all const.

    To Reenter (After Interrupting), or Not to Reenter (Just Hang Out)

  This development jewel sufficed to get the QueryPlan class range query member functions
  working, and then it was time to tackle doing the void join() recursion. The query plan is
  completed by constexpr void initJoin(), which sets up the variable frame array (which became
  necessary at this scale from the intolerance to local variables in recursion) and a plan to
  imitate driver logic was chosen.

  Drivers, which need to be interruptible by other drivers of higher priority, used to save their
  state by saving their registers, scratchpads, and interrupt stack somewhere, or simply by
  pushing down the context via some mechanism supported by the CISC architecture, and now in RISC
  it is assumed this must be done by hand. It was hoped that keeping all these recursion locals
  in a static global array of frames might allow cheating on that to work, and then in typical
  server style, the QueryPlan class join having found a valid single joined row, or a rowset of
  joined rows from the join query, would then interrupt itself and return the data to the
  JoinedRow class caller, and thus external iteration would produce a completed array of joined
  rows satisfying the query.

  That effort failed, because the preempted state could not adequately be restored by any
  reentrant coding, the rank impossibility of which should probably be a lemma or even an axiom
  for C++ development. Upon rethinking the strategy, it was noticed that all the possible valid
  joined rows were produced at the bottom of the recursion (packDepth == maxPackDepth) and then
  they could be drained there, if the output array length was known, which it is. Additionally,
  without preemption or reentrancy, the code is faster by not having to trek all the way in and
  out in on every joined row or joined rowset, iterating across the giant outer loop. If a remote
  interface replying rowsets is needed later, a counting semaphore will probably guard the output
  array while it is copied out, while retaining the maximum velocity of the inner loop.

  Having made that work, and with an incomplete friend ostream& operator<< (ostream &os, const
  QueryPlan& rhs) for the QueryPlan class (nothing much to print in the query plan, for now,) the
  death zone at the summit of join, which now seemed like home after an extended stay, was
  abandoned for the descent to the base camp. [There is a lot of dead code in JoinedRow.h that is
  retained for future refactoring and extension of the current code base.]

  JoinedRow Class

  A lightweight relational JoinedRow class is defined by the identical template class parameters
  as its friend class QueryPlan and is coupled to that plan at runtime

  JoinedRow class objects are microscopic (a 4-byte int per table participating in the join)
  compared to the table and index data that they reference directly, and the indirect access to
  all the metadata on all those tables and every other column and index on those columns in those
  tables.

  In the same way that tables of RowString class objects should not be sorted and that multiple
  indexes of IndexString class objects on those tables are intended for sorting, it is also true
  that arrays of JoinedRow class objects  should not be sorted and that indexes of JoinedIndex
  class objects on those arrays are intended for sorting. However, there are no JoinedIndex
  objects yet in the current code base, because a hack was sufficient to get the demo programs
  working. That hack reveals the method by which the JoinedIndex class will be constructed in the
  future. Note that the ordering of the joined row by an external index required no storage of an
  index string in the joined row element, even to allow range queries on the joined row array.
  Hence, JoinedIndex objects will not contain strings, only a single K-value and the type
  inference to an index element or table row containing the string. Very, very small indexes
  indeed.

  Since the only indexing on the joins and memoized joins (described below) that was needed for
  the demo programs was indexing on the from-column of the first RelationVector in the common
  parameter pack of the QueryPlan class and the JoinedRow class, the shortcut used was to add
  comparison operators to the JoinedRow class that compared against that from-column text. Then
  by sorting the array of joined row objects after completion of any query (these are tiny
  objects, even the seven-table memoized joined row object in BigJoinDemo is only 28 bytes), then
  that array can be accessed directly in sorted order with a range query. The difference in
  performance incurred in accessing an index on the joined row query output will ultimately be
  nil, because they both use the tuple for referencing data and metadata in the database. The
  difference in using an index on memoized joined rows versus sorting the memoized joined row
  output will not be nil as the number of tables in the join grows, or as the table sizes get
  enormous. Hence, indexes on joined rows will be needed later.

  After that there is a constexpr void dropAnchor(queryPlanType* queryPlan) member function to
  connect up the joined row and its associated query plan, and a friend ostream& operator<<
  (ostream &os, const JoinedRow& rhs) member function for printing out the rows of the tables
  being joined in this one JoinedRow class object.

  Normal joins are launched with a single char string value as the key, which is used in a range
  query on the from-index of the first relation vector in the template parameter pack to the
  QueryPlan class (and identically, to the JoinedRow class.) That seeds the nested loop join
  query with one or more rows from the zeroeth table soft-defined from the template parameter
  pack of input relation vectors to the class, into the joined row successive K-values.

  Memoized Joins

  Memoized joins are created by using an asterisk char string as the input to the nested loop
  join (“*”.) That means that the input rows seeding the nested loop join algorithm are every row
  of that first index. This query will produce every possible valid joined row from the database,
  sorted (for now) by the from-index of the first relation vector in the template parameter pack
  to the QueryPlan class.

  This allows that a range query on that memoized join output will produce the same output that
  running the join again would produce, but only for the cost of one range query and a sequential
  scan of the memoized joined row output. That is very fast, and is the reason that if you ignore
  the data processing of those output joined rows, they are made available in sequential order
  for the cost of a single range query, and do not have to be moved somewhere. Similarly, once
  joined rows are indexed, that will be true sequentially, for every column in every table in the
  joined row output that has an index for that column.

  At that point all joins will be effectively free of runtime cost, independent of the number of
  tables participating, or even the size of the tables and the size of the output. Range queries
  using two binary searches have an average cost of approximately 2(log2(n)-1) for consistent
  databases (because range queries rarely fail in joins in real databases), where n is the number
  of the output joined rows (the current code base uses two binary searches on the lower and
  upper range barriers, the second of which could be optimized for small output sets, but that’s
  harder to model than 2(log2(n)-1), so that optimization was forgone for now,) but since you
  only do one range query to get sequential access to the results, the time complexity for
  memoized joins is still effectively constant time: access cost being much cheaper than
  processing the contiguous array of results.

*/

#include <iostream>
#include <memory>
#include <functional>
#include <type_traits>
#include "RowString.h"
#include "IndexString.h"
#include "RelationVector.h"

using namespace std;

// if you are going to modify variables inside template class constexpr, they must be static globals

static void* queryPlanAnchor;
static std::size_t joinedRowIndex;
static int joinedRowRow;
static std::size_t packCursor;
static char* searchTerm; // used by the 4 search recursion routines
static bool memoizedJoin;
static bool branchTableFound;
static bool initialSearchFailed;
static bool tablesIndexed[50];
static int returnValue;
static bool arrayFull;
static char firstTerm[50];
static char* firstSearchTerm = firstTerm; // used by the join recursion routine
static char emptyChars[] = "";
static std::size_t arraySize;
static std::size_t arrayOffset;

enum class TableSource
{
    nilSource, from, to, init
};

struct recursionContextFrame
{
    /* One for each of the classPack parameter pack items. We treat the parameter pack like an array, but it is  actually a constexpr recursion. All local variables used at a particular packDepth, must be here, because of issues with the compiler. The calling parameters and returns between levels are globals above, because constexpr cannot modify template class type variables: they are read-only.
    */
    bool initialized;
    int linkingTablePack;
    TableSource linkingTableSource;
    char* lastFailedSearchTerm;
    Column fromColumn;
    Table fromTable;
    int fromOffset;
    void* from;
    char* fromSearchTerm;
    int fromIndexRangeLow;
    int fromCursor;
    int fromIndexRangeHigh;
    int fromRowKValue;
    Column toColumn;
    Table toTable;
    int toOffset;
    void* to;
    char* toSearchTerm;
    int toIndexRangeLow;
    int toCursor;
    int toIndexRangeHigh;
    int toRowKValue;
};

static recursionContextFrame frame[50];

template <typename... classPack>
class QueryPlan
{
public:
    static const std::size_t arrayCount = (sizeof...(classPack)) + 1;
    typedef tuple<classPack...> relVecsTupleType;

    struct JoinedRowStruct
    {
        int k[arrayCount];
    };

    JoinedRowStruct* callerJoinedRow;

    class Bad_RowString_Anchor : public runtime_error
    {
    public:
        Bad_RowString_Anchor() :
            runtime_error("after allocation, you MUST call rowArray[0].dropAnchor(rowArray, correct_arrayCount)") {}
    };

    class Variadic_Parameter_Pack_Logic_Failed : public runtime_error
    {
    public:
        Variadic_Parameter_Pack_Logic_Failed() :
            runtime_error("somehow, the counting of JoinedRow elements is wrong versus relational vectors.") {}
    };

    class Relation_Vector_Linkage_Rule_Violation : public runtime_error
    {
    public:
        Relation_Vector_Linkage_Rule_Violation() :
            runtime_error("Linkage Rule: after the first one, every successive relation vector's from-index, must be on a table already linked from or to") {}
    };

    class Range_Search_Consistency_Failure : public runtime_error
    {
    public:
        Range_Search_Consistency_Failure() :
            runtime_error("if range low is found, same key range high must also be.") {}
    };

    class Tuple_Consistency_Failure : public runtime_error
    {
    public:
        Tuple_Consistency_Failure() :
            runtime_error("something is wrong with the tuple of relation vectors.") {}
    };

    class Flag_Consistency_Failure : public runtime_error
    {
    public:
        Flag_Consistency_Failure() :
            runtime_error("flags are not consistent with the circumstances.") {}
    };

    class Return_Consistency_Failure : public runtime_error
    {
    public:
        Return_Consistency_Failure() :
            runtime_error("returned value is not consistent with the circumstances.") {}
    };

    class Initialization_Failure : public runtime_error
    {
    public:
        Initialization_Failure() :
            runtime_error("Join context frame not initialized.") {}
    };

    constexpr void emptyFunc() const
    {
        return;
    };

    constexpr bool startJoin(char term[]) const
    {
        strcpy(firstTerm, term);
        initJoin<classPack...>();
        return true;
    }

    constexpr bool startFullMemoizedJoin() const
    {
        firstTerm[0] = '*';
        firstTerm[1] = 0;
        initJoin<classPack...>();
        return true;
    }

    inline int join(JoinedRowStruct* j, std::size_t arrayLen)
    {
        // context from previous calls: firstSearchTerm
        arraySize = arrayLen;
        arrayFull = false;
        callerJoinedRow = j;
        join<classPack...>();
        frame[0].initialized = false; // catch any spurious calls without a new start
        return (arrayFull) ? -arrayOffset : arrayOffset;
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type initJoin() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void initJoin() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace) cout << endl << "initJoin() packDepth = " << packDepth << endl << endl;

        // these are compile-time only, no runtime cost
        typedef decltype(((packFirst*)0)->r.from) fromType;
        const Column fromColumn = ((fromType)0)->enumColumn();
        const Table fromTable = column2Table(fromColumn);
        typedef decltype(((packFirst*)0)->r.to) toType;
        const Column toColumn = ((toType)0)->enumColumn();
        const Table toTable = column2Table(toColumn);
        const int toOffset = (int)toTable;

        frame[packDepth].linkingTablePack = INT_MIN;
        frame[packDepth].linkingTableSource = TableSource::nilSource;
        frame[packDepth].lastFailedSearchTerm = emptyChars; // debug item
        frame[packDepth].fromColumn = fromColumn;
        frame[packDepth].fromTable = fromTable;
        frame[packDepth].from = (get<packDepth>(relVecsTuple).fromIndex());
        frame[packDepth].fromSearchTerm = emptyChars;
        frame[packDepth].fromIndexRangeLow = INT_MIN;
        frame[packDepth].fromCursor = INT_MIN;
        frame[packDepth].fromIndexRangeHigh = INT_MIN;
        frame[packDepth].fromRowKValue = INT_MIN;
        frame[packDepth].toColumn = toColumn;
        frame[packDepth].toTable = toTable;
        frame[packDepth].toOffset = toOffset; // debug item
        frame[packDepth].to = (get<packDepth>(relVecsTuple).toIndex());
        frame[packDepth].toSearchTerm = emptyChars;
        frame[packDepth].toIndexRangeLow = INT_MIN;
        frame[packDepth].toCursor = INT_MIN;
        frame[packDepth].toIndexRangeHigh = INT_MIN;
        frame[packDepth].toRowKValue = INT_MIN;
        frame[packDepth].initialized = true;

        branchTableFound = false;

        if (packDepth == 0)
        {
            frame[packDepth].linkingTableSource = TableSource::init;
        }
        else
        {
            for (int i = packDepth; i >= 0; i--)
            {
                if (i == packDepth) continue; // if you set i to packDepth - 1, the compile dies
                if (frame[packDepth].fromTable == frame[i].toTable)
                {
                    branchTableFound = true;
                    frame[packDepth].linkingTablePack = i;
                    frame[packDepth].linkingTableSource = TableSource::to;
		    break;
                }
                if (frame[packDepth].fromTable == frame[i].fromTable)
                {
                    branchTableFound = true;
                    frame[packDepth].linkingTablePack = i;
                    frame[packDepth].linkingTableSource = TableSource::from;
		    break;
                }
            }
            if (!branchTableFound) throw Relation_Vector_Linkage_Rule_Violation();
        }

        initJoin<packRemaining...>(); // init them all immediately

        return;
    };

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type join() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    void join()
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        const std::size_t maxPackDepth = sizeof...(classPack) - 1;
        if (debugTrace) cout << endl << "join() packDepth = " << packDepth << endl << endl;

        // these are compile-time only, no runtime cost
        typedef decltype(((packFirst*)0)->r.from) fromType;
        const Column fromColumn = ((fromType)0)->enumColumn();
        typedef decltype(((packFirst*)0)->r.to) toType;

        if (packDepth == 0) arrayOffset = 0;

        if(packDepth > maxPackDepth)
            throw Variadic_Parameter_Pack_Logic_Failed(); // the constants are seriously out of whack.
        else
        {
            if (!frame[packDepth].initialized) throw Initialization_Failure();

            initialSearchFailed = false;

            if (packDepth == 0)
            {
                memoizedJoin = false;
                if (!(firstSearchTerm[0] == '*' && firstSearchTerm[1] == 0)) // normal join: range query on the join search term
                {
                    frame[packDepth].fromIndexRangeLow = searchRangeLowFrom(0, firstSearchTerm);
                    if (frame[packDepth].fromIndexRangeLow < 0)
                    {
                        initialSearchFailed = true;
                        frame[packDepth].lastFailedSearchTerm = firstSearchTerm;
                    }
                    else frame[packDepth].fromIndexRangeHigh = searchRangeHighFrom(0, firstSearchTerm);
                    frame[packDepth].fromCursor = frame[packDepth].fromIndexRangeLow;
                    frame[packDepth].fromRowKValue = ((((fromType)frame[packDepth].from)[frame[packDepth].fromCursor]).KValue());
                }
                else // memoized join: the range is [0..end] of the index
                {
                    memoizedJoin = true;
                    frame[packDepth].fromIndexRangeLow = 0;
                    frame[packDepth].fromIndexRangeHigh = (((fromType)frame[packDepth].from)->count()) - 1;
                    frame[packDepth].fromCursor = frame[packDepth].fromIndexRangeLow;
                    frame[packDepth].fromRowKValue = ((((fromType)frame[packDepth].from)[frame[packDepth].fromCursor]).KValue());
                }
                frame[packDepth].fromSearchTerm = firstSearchTerm;
            }
            else // from the linked row (which is our row), get their row index and set ours, and set the from search term
            {
                frame[packDepth].fromIndexRangeLow = INT_MIN; // if we index by these below -> segfault
                frame[packDepth].fromIndexRangeHigh = INT_MIN; // these should be unchanged from initialization
                frame[packDepth].fromCursor = INT_MIN;
                if (frame[packDepth].linkingTableSource == TableSource::from)
                {
                    frame[packDepth].fromRowKValue = frame[frame[packDepth].linkingTablePack].fromRowKValue;
                    frame[packDepth].fromSearchTerm = ((((fromType)frame[packDepth].from)
                                                        ->rowAnchor())[frame[packDepth].fromRowKValue]).columnStr(fromColumn);
                }
                else if (frame[packDepth].linkingTableSource == TableSource::to)
                {
                    frame[packDepth].fromRowKValue = frame[frame[packDepth].linkingTablePack].toRowKValue;
                    frame[packDepth].fromSearchTerm = ((((fromType)frame[packDepth].from)
                                                        ->rowAnchor())[frame[packDepth].fromRowKValue]).columnStr(fromColumn);
                }
                else throw Initialization_Failure();
            }

            if (!initialSearchFailed)
            {
                if (!(memoizedJoin && packDepth == 0)) // only one root from search term and from row K value
                    frame[packDepth].toSearchTerm = frame[packDepth].fromSearchTerm;
                for (frame[packDepth].fromCursor = frame[packDepth].fromIndexRangeLow;
                        frame[packDepth].fromCursor <= frame[packDepth].fromIndexRangeHigh;
                        frame[packDepth].fromCursor++)
                {
                    if (memoizedJoin && packDepth == 0) // new search terms and K values for every new row across the first index
                    {
                        frame[packDepth].fromSearchTerm = ((((fromType)frame[packDepth].from)[frame[packDepth].fromCursor]).c_str());
                        frame[packDepth].toSearchTerm = frame[packDepth].fromSearchTerm;
                        frame[packDepth].fromRowKValue = ((((fromType)frame[packDepth].from)[frame[packDepth].fromCursor]).KValue());
                    }
                    frame[packDepth].toIndexRangeLow =
                        binarySearchRangeLow(((toType)frame[packDepth].to),
                                             ((toType)frame[packDepth].to)->count(),
                                             frame[packDepth].toSearchTerm);

                    if (frame[packDepth].toIndexRangeLow >= 0)
                    {
                        frame[packDepth].toIndexRangeHigh
                            = binarySearchRangeHigh(((toType)frame[packDepth].to),
                                                    ((toType)frame[packDepth].to)->count(),
                                                    frame[packDepth].toSearchTerm);

                        if (frame[packDepth].toIndexRangeHigh < 0) throw Range_Search_Consistency_Failure();

                        for (frame[packDepth].toCursor = frame[packDepth].toIndexRangeLow;
                                frame[packDepth].toCursor <= frame[packDepth].toIndexRangeHigh;
                                frame[packDepth].toCursor++)
                        {
                            frame[packDepth].toRowKValue = (((toType)frame[packDepth].to)[frame[packDepth].toCursor]).KValue();

                            join<packRemaining...>();

                            if (sizeof...(packRemaining) == 0) // Found a joinedRow !
                            {
                                if (debugTrace) cout << endl << "join() found one: " << frame[0].fromRowKValue;
                                callerJoinedRow[arrayOffset].k[0] = frame[0].fromRowKValue;
                                for (std::size_t i = 0; i <= packDepth; i++)
                                {
                                    if (debugTrace) cout << ", " << frame[i].toRowKValue;
                                    callerJoinedRow[arrayOffset].k[i + 1] = frame[i].toRowKValue;
                                }
                                if (debugTrace) cout << endl << endl;
                                if (++arrayOffset >= arraySize) arrayFull = true;
                            }

                            if (arrayFull) break;
                        }
                        if (arrayFull) break;
                    }
                }
            }
        }

        return;
    };

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type queryPlanChecker() {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void queryPlanChecker() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace) cout << endl << "queryPlanChecker() index = " << joinedRowIndex << ", packDepth = " << packDepth << endl << endl;
        if (joinedRowIndex < packDepth)
            throw Variadic_Parameter_Pack_Logic_Failed(); // seriously out of whack.

        // these are compile-time only, no runtime cost
        typedef decltype(((packFirst*)0)->r.from) fromType;
        typedef decltype(((packFirst*)0)->r.to) toType;
        const Column fromColumn = ((fromType)0)->enumColumn();
        const Column toColumn = ((toType)0)->enumColumn();
        const int fromTable = (int)column2Table(fromColumn);
        const int toTable = (int)column2Table(toColumn);

        if (joinedRowIndex == 0 && packDepth == 0) tablesIndexed[fromTable] = true;
        else if (joinedRowIndex == packDepth + 1) tablesIndexed[toTable] = true;

        if (!tablesIndexed[fromTable]) throw Relation_Vector_Linkage_Rule_Violation();
        // if neither of these, then call deeper, otherwise just fall through and return
        if (!((joinedRowIndex == 0 && packDepth == 0) || (joinedRowIndex == packDepth + 1)))
            queryPlanChecker<packRemaining...>();

        return;
    };

    constexpr void checkQueryPlan() const
    {
        for (std::size_t i = 0; i < arrayCount; ++i) tablesIndexed[i] = false;
        for (std::size_t i = 0; i < arrayCount; ++i)
        {
            joinedRowIndex = i;
            queryPlanChecker<classPack...>();
        }
    }

    inline QueryPlan(classPack... args)
    {
        checkQueryPlan();
        static relVecsTupleType relVecsTuple = std::make_tuple(args...);
        static_assert((sizeof...(classPack)) == (std::tuple_size<decltype(relVecsTuple)>::value),
                      "Parameter pack size and tuple size must match.");
        // at the very least, other checks  should be made.
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type searchRangeLowFrom() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void searchRangeLowFrom() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace && packCursor == packDepth)
            cout << endl << "searchRangeLowFrom() packCursor = " << packCursor << ", packDepth = " << packDepth << endl << endl;

        if (packCursor > packDepth) searchRangeLowFrom<packRemaining...>();
        else if (packCursor == packDepth)
            returnValue = binarySearchRangeLow((get<packDepth>(relVecsTuple).fromIndex()),
                                               (get<packDepth>(relVecsTuple).fromIndex())->count(), searchTerm);
        else throw Variadic_Parameter_Pack_Logic_Failed(); // less than: seriously out of whack.

        return;
    };

    constexpr int searchRangeLowFrom(int relVecOff, char term[]) const
    {
        packCursor = relVecOff;
        searchTerm = term;
        returnValue = 0;
        searchRangeLowFrom<classPack...>();
        return returnValue;
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type searchRangeLowTo() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void searchRangeLowTo() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace && packCursor == packDepth)
            cout << endl << "searchRangeLowTo() packCursor = " << packCursor << ", packDepth = " << packDepth << endl << endl;

        if (packCursor > packDepth) searchRangeLowTo<packRemaining...>();
        else if (packCursor == packDepth)
            returnValue = binarySearchRangeLow((get<packDepth>(relVecsTuple).toIndex()),
                                               (get<packDepth>(relVecsTuple).toIndex())->count(), searchTerm);
        else throw Variadic_Parameter_Pack_Logic_Failed(); // less than: seriously out of whack.

        return;
    };

    constexpr int searchRangeLowTo(int relVecOff, char term[]) const
    {
        packCursor = relVecOff;
        searchTerm = term;
        returnValue = 0;
        searchRangeLowTo<classPack...>();
        return returnValue;
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type searchRangeHighFrom() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void searchRangeHighFrom() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace && packCursor == packDepth)
            cout << endl << "searchRangeHighFrom() packCursor = " << packCursor << ", packDepth = " << packDepth << endl << endl;

        if (packCursor > packDepth) searchRangeHighFrom<packRemaining...>();
        else if (packCursor == packDepth)
            returnValue = binarySearchRangeHigh((get<packDepth>(relVecsTuple).fromIndex()),
                                                (get<packDepth>(relVecsTuple).fromIndex())->count(), searchTerm);
        else throw Variadic_Parameter_Pack_Logic_Failed(); // less than: seriously out of whack.

        return;
    };

    constexpr int searchRangeHighFrom(int relVecOff, char term[]) const
    {
        packCursor = relVecOff;
        searchTerm = term;
        returnValue = 0;
        searchRangeHighFrom<classPack...>();
        return returnValue;
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type searchRangeHighTo() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void searchRangeHighTo() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        if (debugTrace && packCursor == packDepth)
            cout << endl << "searchRangeHighTo() packCursor = " << packCursor << ", packDepth = " << packDepth << endl << endl;

        if (packCursor > packDepth) searchRangeHighTo<packRemaining...>();
        else if (packCursor == packDepth)
            returnValue = binarySearchRangeHigh((get<packDepth>(relVecsTuple).toIndex()),
                                                (get<packDepth>(relVecsTuple).toIndex())->count(), searchTerm);
        else throw Variadic_Parameter_Pack_Logic_Failed(); // less than: seriously out of whack.

        return;
    };

    constexpr int searchRangeHighTo(int relVecOff, char term[]) const
    {
        packCursor = relVecOff;
        searchTerm = term;
        returnValue = 0;
        searchRangeHighTo<classPack...>();
        return returnValue;
    }

};

template <typename... classPack>
class JoinedRow
{
public:
    typedef QueryPlan<classPack...> queryPlanType;
    friend class QueryPlan<classPack...>;

    static_assert((sizeof...(classPack)) == (std::tuple_size<decltype(relVecsTuple)>::value), "Parameter pack size and tuple size must match."); // at the very least, other checks  should be made.
    static const std::size_t arrayCount = (sizeof...(classPack)) + 1;
    static_assert((queryPlanType::arrayCount == arrayCount), "Query Plan and Joined Row array counts must match.");

    typename queryPlanType::JoinedRowStruct j;

    class Bad_RowString_Anchor : public runtime_error
    {
    public:
        Bad_RowString_Anchor() :
            runtime_error("after allocation, you MUST call rowArray[0].dropAnchor(rowArray, correct_arrayCount)") {}
    };

    class Variadic_Parameter_Pack_Logic_Failed : public runtime_error
    {
    public:
        Variadic_Parameter_Pack_Logic_Failed() :
            runtime_error("somehow, the counting of JoinedRow elements is wrong versus relational vectors.") {}
    };

    constexpr std::size_t tableCount() const
    {
        return arrayCount;
    }

    constexpr std::size_t structSize() const
    {
        return sizeof(j);
    }

    constexpr void emptyFunc() const
    {
        return;
    };

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type joinedRowTupleOutput() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    void joinedRowTupleOutput()
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        //cout << endl << "index = " << joinedRowIndex << ", row = " << joinedRowRow << ", packDepth = " << packDepth << endl << endl;
        if (joinedRowIndex < packDepth) throw Variadic_Parameter_Pack_Logic_Failed();
        // seriously out of whack.

        if (joinedRowIndex == 0 && packDepth == 0)
            cout << ((get<packDepth>(relVecsTuple).fromIndex())->rowAnchor())[joinedRowRow] << endl;
        else if (joinedRowIndex == packDepth + 1)
            cout << ((get<packDepth>(relVecsTuple).toIndex())->rowAnchor())[joinedRowRow] << endl;
        else // if neither of these, then call deeper, otherwise just fall through and return
            joinedRowTupleOutput<packRemaining...>();

        return;
    };

    inline int join(std::size_t arrayCount)
    {
        return ((queryPlanType*)queryPlanAnchor)->join(&j, arrayCount);
    }

    inline void joinedRowPrintTest()
    {
        for (std::size_t i = 0; i < arrayCount; ++i)
        {
            //= {3530,47126,3657,4539} this is a destructive test of the output of the current joinedRow
            j.k[i]=(i==0)?3472:(i==1)?5416:(i==2)?3250:(i==3)?24:j.k[i];
            // Southwest Airlines route from SJC to LAS
            joinedRowIndex = i;
            joinedRowRow = j.k[i];
            joinedRowTupleOutput<classPack...>();
        }
    }

    template<typename... packRemaining>
    constexpr typename std::enable_if<sizeof...(packRemaining) == 0>::type joinedRowOutput() const {} // SFINAE terminated.

    template<typename packFirst, typename... packRemaining>
    constexpr void joinedRowOutput() const
    {
        const std::size_t packDepth = sizeof...(classPack) - sizeof...(packRemaining) -1;
        //cout << endl << "index = " << joinedRowIndex << ", row = " << joinedRowRow << ", packDepth = " << packDepth << endl << endl;
        if (joinedRowIndex < packDepth) throw Variadic_Parameter_Pack_Logic_Failed();
        // seriously out of whack.

        if (packDepth == 0)
        {
            cout << ((get<packDepth>(relVecsTuple).fromIndex())->rowAnchor())[j.k[0]] << endl;
            cout << ((get<packDepth>(relVecsTuple).toIndex())->rowAnchor())[j.k[packDepth + 1]] << endl;
        }
        else
            cout << ((get<packDepth>(relVecsTuple).toIndex())->rowAnchor())[j.k[packDepth + 1]] << endl;

        joinedRowOutput<packRemaining...>();

        return;
    };

    void print()
    {
        joinedRowOutput<classPack...>();
    }

    typedef decltype((get<0>(relVecsTuple).fromIndex())->row()) rowType;

    inline char* c_str()
    {
        Column zeroFromColumnEnum = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        char* zeroFromColumn = this->row()->columnStr(zeroFromColumnEnum);
        return zeroFromColumn;
    };

    inline Column enumColumn()
    {
        return (get<0>(relVecsTuple).fromIndex())->enumColumn();
    };

    rowType row()
    {
        rowType thisRow = reinterpret_cast<rowType>((rowType)&((((get<0>(relVecsTuple).fromIndex())->rowAnchor()))[j.k[0]]));
        return thisRow;
    }

// JoinedRow to JoinedRow comparisons (on the from column of the first relation)

    inline bool operator < (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare < 0);
    };

    inline bool operator <= (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare < 1);
    };

    inline bool operator == (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare == 0);
    };

    inline bool operator != (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare != 0);
    };

    inline bool operator >= (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare > -1);
    };

    inline bool operator > (JoinedRow& rhs)
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), ((rhs.row())->columnStr(zeroFromColumn)));
        return (compare > 0);
    };

// JoinedRow (the from column of the first relation) to char[] comparisons

    inline bool operator < (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare < 0);
    };

    inline bool operator <= (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare < 1);
    };

    inline bool operator == (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare == 0);
    };

    inline bool operator != (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare != 0);
    };

    inline bool operator >= (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare > -1);
    };

    inline bool operator > (const char rhs[])
    {
        Column zeroFromColumn = (get<0>(relVecsTuple).fromIndex())->enumColumn();
        int compare = strcmp(((this->row())->columnStr(zeroFromColumn)), rhs);
        return (compare > 0);
    };

    constexpr void dropAnchor(queryPlanType* queryPlan) const
    // just the queryPlan object
    {
        if ((get<0>(relVecsTuple).fromIndex())->rowAnchor() == 0) throw Bad_RowString_Anchor(); // no tables to index

        queryPlanAnchor = queryPlan;
    }

};

#endif // JOINEDROW_H
