// JoinDemo.cpp - Exploring joins and memoized joins on tables with indexes using Kaldanes

// Please build for release to get good performance

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

  JoinDemo.cpp program

  Exploring joins and memoized joins on tables with indexes using Kaldanes

  The OpenFlights.org Air Routes Database

  The database used was accessed from the database used by OpenFlights.org. The files contain
  data on all the air routes, airports, and airlines as of 2009, not maintained since. At that
  time there were 65,612 valid air routes (with valid source and destination airports, and
  airlines.) It’s a small database, only 3.5 MB, but you can do big joins on a small database.
  In reference to the relatively small size of database used in the demo programs, the argument
  for whether the current code base will scale to enormous size, has three parts: (1) the index
  sorts are linear time complexity relative to the count of rows while using a small PMNK index
  element, (2) the nested loop joins are linear time complexity relative to the number of output
  joined rows, and also linear relative to the number of range queries, which have an average
  2(log2(n)-1) time complexity for consistent databases, where n is the number of table rows,
  and (3) the memoized join time complexity is effectively constant time. If you think of the
  compile cost as including the memoized join cost, then compiling the relational database
  queries only occurs one time per generation of the database.

  At OpenFlights.org, the data is stored in .dat files, those were converted to .csv files by
  removing quoted strings and replacing commas in those quoted strings with semicolons to
  satisfy the limited .csv input functioning of the current code base. Everything is #-commented
  (R .csv style) in the resulting .csv files presented in the code base.

  The relations between the demo program tables are (1) many airlines serve many airports [m:m],
  (2) routes are flown by one airline + airlines serve many routes [1:m], and (3 and 4) routes
  have one source and destination airport + airports have many source routes [1:m] and many
  destination routes [1:m].
   __________________________________________________________________________________________
  |                                                                                          |
  |                           OpenFlights.org Air Routes Database                            |
  |     ________________                                               ________________      |
  |    |                |_                                           _|                |     |
  |    |                | \                                         / |                |     |
  |    |    Airlines    |----------------- serving [m:m] -------------|    Airports    |     |
  |    |                |_/                                         \_|                |     |
  |    |________________|                                             |________________|     |
  |            |                                                          |       |          |
  |            |                                                         /        |          |
  |            :                            .--- source [m:1] ----------'         |          |
  |             \                          /                                      |          |
  |              \                        /                                       |          |
  |             flying                   |                                        |          |
  |               [1:m]                 /|\                                       |          |
  |                 \            ______|_|_|______                                |          |
  |                  \         _|                 |_                              ;          |
  |                   \       / |                 | \                            /           |
  |                    `--------|     Routes      |------ destination [m:1] ----'            |
  |                           \_|                 |_/                                        |
  |                             |_________________|                                          |
  |                                                                                          |
  |                                                                                          |
  |__________________________________________________________________________________________|

  Once again, the JoinDemo program, as all the demo programs do, has two sections before the
  main() function: (1) a Static Metadata Section (SMS) laid out in an absolutely order critical
  way containing everything (classes, types, static data, const and constexpr) that is needed
  for generic programming (compile-time) of the relational database system, and (2) an Active
  Program Section (APS) laid out in whatever order that is desired, in this case containing
  performance analysis declarations and functions, data loading and printing functions, and a
  runtime checker to partially guarantee the consistency of columns versus tables in the layout
  in the SMS.

  All of the elements of the main() function, are executed within an anonymous exception
  handler, that prints out the ugly extended name of the exception with the readable name at the
  end, and that also works in release code for bug analysis during performance testing.

  JoinDemo keeps track of the time consumed by operations and printing those operations
  separately, using the nanosecond clock facility of C++11 on Linux. Initially it builds the
  database:

  1.    The three tables are allocated and loaded from .csv files and then anchored into RowString
        arrays.
  2.    Space for the ten indexes on those three tables is allocated.
  3.    The table source anchor is copied into the indexes, the index keys are copied into the
        indexes from the tables, and the indexes are sorted.

  At this point the database is up and ready to query: for the three relational database system
  demos (TableDemo, JoinDemo and BigJoinDemo,) the average time to produce the database and
  bring it up from scratch using input .csv files was 115.556 ms, less than 1/8th of a second.

  JoinDemo executes query logic on the scale of the entire size of the database. The relations
  are slightly different, but it uses the identical schema presented in the picture above, simply
  going at those 65,612 valid air routes from the access path of airlines instead of airports.
  The query for JoinDemo identifies and counts the valid routes for the top ten air carriers in
  the world. The output for JoinDemo is in the Appendix after TableDemo.

  The code is very similar to TableDemo up to the point of completing the QueryPlan type and
  object. Three modified RelationVector objects are created and incorporated into a different
  QueryPlan: (1) an airline flying some routes, (2) some routes relating to their source airport
  and (3) some routes relating to their destination airport. Whereas TableDemo viewed the total
  set of valid air routes from the aspect of airport, JoinDemo views the identical total set from
  the aspect of airline.

  First, a lambda is created to execute a standard nested loop join query on the database
  yielding all the air routes for a specific airline, and then printing the performance
  statistics and the count of that airline’s air routes. That standard join lambda is executed
  for the top ten airlines (by passengers carried) in the world.

  Two things are apparent from the data: (1) Ryanair/Ireland, the number five in passengers
  carried has more routes than any other, presumably with shorter hops and fewer passengers per
  flight and (2) there is a correlation between (a) the number of identified valid air routes,
  (b) the number of range queries executed in the nested loop join, and (c) the execution time.

  Roughly, that comparison reduces to one valid air route, per two range queries, per
  microsecond. The time complexity, or scale up in the common parlance, for nested loop joins on
  this relational database system is thus measured as linear time, with a record tiny scale
  factor (IMHO.)

  Second, a memoized join is created recording all of the valid routes for all airlines in the
  very compact form of 16 bytes per joined row. This takes 70,115 microseconds for all 65,612
  valid air routes and once again: roughly one valid air route, per two range queries, per
  microsecond for that nested loop join to execute in linear time. The cost of storing that
  memoized join is 1,049,792 bytes (1MB.) FYI, any indexes (using the JoinedIndex class in the
  future) built on that memoized join for doing relational database “select” operations, for any
  column of any participating table, would cost 262,448 bytes (¼MB) to store. Each corresponding
  index of JoinedIndex objects would take roughly 10ms (linear time) to build on-the-fly,
  according to the sort data, but of course in an mmapped slab database that cost would only
  affect the producer, not the consumer.

  Once again, the ordering of the future JoinedIndex object by an external index will require no
  storage of an index string in the joined index element, even to allow range queries on the
  joined row array: hence, JoinedIndex objects will not contain strings, only a single K-value
  and the type inference to an index element or table row containing the string. This will be
  also be true for combination key indexes on the tables and on the joined row arrays containing
  the memoized query data. The type information is in the template directing the parameter pack
  recursion to soft-define these relationships: once data is stored somewhere it is accessible in
  any combination of relationships.

  Third, a lambda is created to execute a memoized join query yielding the same effect as the
  standard joins above in the first step, including creating an array of joined row output
  containing the air routes for a specific airline, and then printing the performance statistics
  and the count of that airline’s air routes. That memoized join lambda is executed for the top
  ten airlines (by passengers carried) in the world.

  The results of the ten memoized joins are identical to the standard joins, except for the
  performance numbers. Of course, there is only a single range query for every memoized join
  query, because a memoized join query consists of a range query on the memoized join output
  array for the database. There is a rough correlation between (a) the number of identified valid
  air routes and (b) the execution time: that reduces to roughly 2-4 nanoseconds per valid air
  route reported, which is a speedup of three orders of magnitude for memoized join queries over
  standard nested loop join queries that require a couple of range queries per output joined row
  by the time you reach the bottom of the join recursion. This kind of relational database query
  performance at the nanosecond level for a single or point query result is unprecedented (IMHO.)

  Memoized joins do effectively require that you compile the database along with the database
  code, but you only need to do that one time to create an mmapped slab that can be shared
  countless times at memory access speeds in the proper environment (Gen-Z, 3D XPoint.)

*/

#include <iostream>
#include <fstream>
#include <climits>
#include <iostream>
#include <stddef.h>
#include <algorithm>
#include <cstring>
#include <tuple>
#include <chrono>
#include <climits>
#include <typeinfo>

#ifdef __GNUG__
#include <cxxabi.h> // gcc only: fetching type names
#endif // __GNUG__

#define NAME_OF(variable) ((void)variable, #variable)

static const bool debugTrace = false;

using namespace std;
using namespace std::chrono;

// Banners from: http://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=Section
// Using ANSI Shadow font

/*
███████╗      ███╗   ███╗        ███████╗
██╔════╝      ████╗ ████║        ██╔════╝
███████╗      ██╔████╔██║        ███████╗
╚════██║      ██║╚██╔╝██║        ╚════██║
███████║tatic ██║ ╚═╝ ██║etadata ███████║ection
╚══════╝      ╚═╝     ╚═╝        ╚══════╝

Goal: What would reside in a database catalog and execute at runtime (compiler, optimizer, etc.)
instead lives in type space and executes at compile time.

Everything in this section (classes, types, static data, const and constexpr)
is needed for generic programming (compile-time)

*/

template<typename T>
void displayNameOfType(T elem)
{
    string typeName = typeid(T).name();

#ifdef __GNUG__
    int status = 0;
    char *readableName = abi::__cxa_demangle(typeName.c_str(), NULL, NULL, &status);
    if (status == 0)
    {
        typeName = readableName;
        std::free(readableName);
    }
#endif // __GNUG__

    cout << typeName;
}

// Order is critical ...

// Needed to reinterpret_cast later
static const std::size_t maxColumnSizeDefault = 1024;
static const std::size_t pmnkSizeDefault = 7;

enum class Table
{
    airports,
    airlines,
    routes,

    table_Count,
    nilTable = INT_MIN
};
// insert new tables before table_Count, please

static char* charRowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static void* rowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static std::size_t rowCounts[(int)Table::table_Count] = {0}; // ditto, and index length = table length.

enum class Column // must be in the order of Table, above
{
    // 14 airports table columns
    airportId,
    airportName,
    airportCity,
    airportCountry,
    airportIATA,
    airportICAO,
    airportLatitude,
    airportLongitude,
    airportAltitude,
    airportTimezone,
    airportDST,
    airportTz,
    airportType,
    airportSource,

    airportsDivider,

    // 8 airlines table columns
    airlineId,
    airlineName,
    airlineAlias,
    airlineIATA,
    airlineICAO,
    airlineCallsign,
    airlineCountry,
    airlineActive,

    airlinesDivider,

    // 9 routes table columns
    routeAirline,
    routeAirlineId,
    routeSourceAirport,
    routeSourceAirportId,
    routeDestinationAirport,
    routeDestinationAirportId,
    routeCodeshare,
    routeStops,
    routeEquipment,

    routesDivider,

    columnCount, // accessing the array with this enum's static should segfault
    nilColumn = INT_MIN // accessing the array with this enum's static should segfault
};
// insert new columns in order before columnCount,
// please, then adjust the table of IDs below

// Index metadata resides in these (3) arrays
static char* charIndexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static void* indexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static std::size_t indexCounts[(int)Column::columnCount] = {0}; // ditto, and index length = table length.

typedef std::size_t OffsetValue;
static const OffsetValue trammel = UINT_MAX; // to catch the alignment bugs
static const OffsetValue columnId[(int)Column::columnCount + 2] =
// This array translates from the Column enum to the column ID in the specific table.
// THEY NEED TO BE MAINTAINED IN ALIGNMENT!
// "It must be mounted on a tripod!": see "The Wild Bunch" by Peckinpah (director's cut)
// It is effectively the database catalog metadata.
// Use the assertion checker below
// Sorry, this is the only thing I couldn't automate easily and reliably! Variadic templates, later?
{
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,trammel,// 14 valid airports column IDs

    0,1,2,3,4,5,6,7,trammel,// 8 valid airlines column IDs

    0,1,2,3,4,5,6,7,8,trammel,// 9 valid routes column IDs

    trammel,trammel // Everything accessing a trammel as an index should segfault
};

class Improperly_Maintained_columnId_Table : public runtime_error
{
public:
    Improperly_Maintained_columnId_Table() :
        runtime_error("the columnId table relationship to Column enums is broken") {}
};

void columnIdChecker()
{
    if (columnId[(int)Column::airportsDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::airlinesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::routesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
}

class Invalid_Column_Enum_Class_Member : public runtime_error
{
public:
    Invalid_Column_Enum_Class_Member() :
        runtime_error("the Column enum class element is not a valid member") {}
};

// Had the above gone well this will work fine
constexpr Table column2Table(Column columnEnum)
{
    return (columnEnum < Column::airportsDivider) ? Table::airports
           : (columnEnum < Column::airlinesDivider) ? Table::airlines
           : (columnEnum < Column::routesDivider) ? Table::routes
           : Table::nilTable;
}

#include "RowString.h"
#include "IndexString.h"

const std::size_t airportsMaxLen = 186, airportsColumns = 14, airportsCount = 7184;
const char airportsFile[] = "./airports.csv";
typedef RowString<char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault> airportRow;

const std::size_t airlinesMaxLen = 404, airlinesColumns = 8, airlinesCount = 6162;
const char airlinesFile[] = "./airlines.csv";
typedef RowString<char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault> airlineRow;

const std::size_t routesMaxLen = 65, routesColumns = 9, routesCount = 67663;
const char routesFile[] = "./routes.csv";
typedef RowString<char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault> routeRow;

// Compile time (static) programming is difficult in c++11
template<Column columnEnum>
constexpr decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                   : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                   : (columnEnum < Column::routesDivider) ? (routeRow*)0
                   : (void*)0) column2RowStringPtr()
{
    return (decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                     : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                     : (columnEnum < Column::routesDivider) ? (routeRow*)0
                     : (void*)0)) (columnEnum < Column::airportsDivider) ? reinterpret_cast<airportRow*>(rowAnchors[(std::size_t)Table::airports])
           : (columnEnum < Column::airlinesDivider) ? reinterpret_cast<airlineRow*>(rowAnchors[(std::size_t)Table::airlines])
           : (columnEnum < Column::routesDivider) ? reinterpret_cast<routeRow*>(rowAnchors[(std::size_t)Table::routes])
           : (void*)0;
}

typedef IndexString<Column::airportId, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportIdType;
typedef IndexString<Column::airportName, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportNameType;
typedef IndexString<Column::airportCountry, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportCountryType;
typedef IndexString<Column::airportIATA, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportIATAType;
typedef IndexString<Column::airportICAO, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault> airportICAOType;
typedef IndexString<Column::airlineId, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault> airlineIdType;
typedef IndexString<Column::airlineCountry, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault> airlineCountryType;
typedef IndexString<Column::routeAirlineId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeAirlineIdType;
typedef IndexString<Column::routeSourceAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeSourceAirportIdType;
typedef IndexString<Column::routeDestinationAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault> routeDestinationAirportIdType;

#include "RelationVector.h"

typedef RelationVector<airlineIdType, routeAirlineIdType> airlineId2RouteAirlineIdType;
typedef RelationVector<routeSourceAirportIdType, airportIdType> routeSourceAirportId2AirportIdType;
typedef RelationVector<routeDestinationAirportIdType, airportIdType> routeDestinationAirportId2AirportIdType;

typedef tuple<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType> routesJoinRelationsTupleType;
routesJoinRelationsTupleType relVecsTuple;

#include "JoinedRow.h"
typedef QueryPlan<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType> routesQueryPlanType;
typedef JoinedRow<airlineId2RouteAirlineIdType, routeSourceAirportId2AirportIdType, routeDestinationAirportId2AirportIdType> routesJoinedRowType;


/*
 █████╗       ██████╗   ███████╗
██╔══██╗      ██╔══██╗  ██╔════╝
███████║      ██████╔╝  ███████╗
██╔══██║      ██╔═══╝   ╚════██║
██║  ██║ctive ██║rogram ███████║ection
╚═╝  ╚═╝      ╚═╝       ╚══════╝

Nothing in this section has definitions that the generic programming (compile-time) requires.

*/

// Statistics
duration<double, nano> runTime;
duration<double, nano> testTime;
duration<double, nano> standardJoinTime;
duration<double, nano> memoizedJoinTime;
duration<double, nano> totalTime;
double rangeQueriesStart;

void resetStats()
{
    testTime = duration<double, nano> (0);
    standardJoinTime = duration<double, nano> (0);
    memoizedJoinTime = duration<double, nano> (0);
    totalTime = duration<double, nano> (0);
    rangeQueries = 0;
    rangeQueriesStart = 0;
}

void displayTime(const char text[])
{
    cout.precision(3);
    cout << "Time for " << text << " = " << fixed << chrono::duration <double, micro> (testTime).count() << " microseconds." << endl;
}

void displayTime(const char text[], duration<double, nano> time)
{
    cout.precision(3);
    cout << "Time for " << text << " = " << fixed << chrono::duration <double, micro> (time).count() << " microseconds." << endl;
}

void displayRangeQueries()
{
    int queries = rangeQueries - rangeQueriesStart;
    cout.precision(0);
    cout << "Using " << fixed << queries << ((queries == 1) ? " range query." : " range queries.") << endl;
}

void displayStats()
{
    cout << std::string(80, '_') << endl << endl;
    cout << "Statistics for the run of the program, including:" << endl;
    cout << "   1. Allocating and loading three tables from CSV files on disk, around 80K rows." << endl;
    cout << "   2. Allocating, copying the keys and sorting ten indexes on those three tables." << endl;
    cout << "   3. Creating three relation vectors, each containing a from-index and a to-index." << endl;
    cout << "   4. Creating a tuple from those three relation vectors to store the query objects." << endl;
    cout << "   5. Creating and optimizing a database join query plan for those three relation vectors." << endl;
    cout << "   6. Creating a joined row output array and doing ten nested loop join queries into it for the top ten airlines." << endl;
    cout << "   7. Doing a full memoized loop join query for all airlines into it." << endl;
    cout << "   8. Doing ten memoized join queries into arrays for the top ten airlines." << endl << endl;
    cout.precision(5);
    cout << "Total run time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> (runTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total relational database system time spent in main() procedure thus far, including I/O = "
         << fixed << chrono::duration <double, micro> (totalTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total display output time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> ((runTime - totalTime)/1000000).count() << " seconds" << endl;
    cout << std::string(80, '_') << endl << endl;
}

class Boolian_Error : public runtime_error
{
public:
    Boolian_Error() :
        runtime_error("boolian operator failure") {}
};

class Could_Not_Open_File : public runtime_error
{
public:
    Could_Not_Open_File() :
        runtime_error("file name could not be opened") {}
};

class Array_Not_Sorted : public runtime_error
{
public:
    Array_Not_Sorted() :
        runtime_error("Array items are not in sorted order") {}
};

class Output_Array_Size_Not_Big_Enough : public runtime_error
{
public:
    Output_Array_Size_Not_Big_Enough() :
        runtime_error("Array size not big enough for output: more JoinedRows than space") {}
};

template<typename T>
void throwExceptionIfUnsorted(T arr[], int size)
{
    for (int i = 1; i < size - 1; ++i)
    {
        if (arr[i - 1] > arr[i])
        {
            throw Array_Not_Sorted();
        }
    }
    return;
}

template<typename T>
void loadCSVFile(T arr[], int size, const char filename[])
{
    ifstream csvFile(filename);
    if (!csvFile)
    {
        throw Could_Not_Open_File();
    }
    for (int i = 0; (csvFile) && i <= size; i++)
    {
        char input;
        csvFile >> input;
        if (input == '#') // pass over R Language comment lines beginning with a '#'
        {
            csvFile.ignore(numeric_limits<streamsize>::max(), '\n');
            i--;
        }
        else
        {
            csvFile.putback(input);
            csvFile >> arr[i];
        }
    }
    csvFile.close();
}

class Type_Not_Supported_Here : public runtime_error
{
public:
    Type_Not_Supported_Here() :
        runtime_error("that type is not supported in this function") {}
};

template<typename T>
void printIndex(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++) cout << *(arr[i].row()) << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printTable(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isRowString[] = "RowString";
    if (strstr(typeName.c_str(), isRowString))
    {
        for (int i = 0; i < size; i++) cout << arr[i] << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printJoin(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isJoinedRow[] = "JoinedRow";
    if (strstr(typeName.c_str(), isJoinedRow))
    {
        for (int i = 0; i < size; i++)
        {
            cout << std::string(133, '-') << endl;
            arr[i].print();
        }
        cout << std::string(133, '-') << endl << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printIndexColumn(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++)
        {
            cout << arr[i] << endl;
//            cout << arr[i];
//            if (i + 1 < size) cout << " ";
//            else cout << endl;
        }
    }
    else throw Type_Not_Supported_Here();
}

void asserts()
{
    columnIdChecker();
}

class Logic_Error : public runtime_error
{
public:
    Logic_Error() :
        runtime_error("something terribly wrong if you can't allocate an array.") {}
};

int main()
{
    cout << endl << endl << "[Note: Remember to set the C++11 switch in the IDE or compiler!" << endl << endl
         << " Remember to use release builds if you are analyzing performance," << endl
         << "   otherwise Index builds will be very slow!" << endl << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited," <<endl
         << "   otherwise it can die!]" << endl;

    //airports, airlines, routes
    try
    {
        // Anonyomous catch -> exception names in release code execution

        asserts();

        high_resolution_clock::time_point runStart = high_resolution_clock::now();

        // Tables
        high_resolution_clock::time_point start = high_resolution_clock::now();

        airportRow airports[airportsCount];
        airports[0].dropAnchor(airports, airportsCount);
        loadCSVFile(airports, airportsCount, airportsFile);

        airlineRow airlines[airlinesCount];
        airlines[0].dropAnchor(airlines, airlinesCount);
        loadCSVFile(airlines, airlinesCount, airlinesFile);

        routeRow routes[routesCount];
        routes[0].dropAnchor(routes, routesCount);
        loadCSVFile(routes, routesCount, routesFile);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        cout << endl << endl;
        displayTime("space allocating and loading the three tables from CSV files");

        // Index space allocation
        start = high_resolution_clock::now();

        airportIdType airportsId[airportsCount];
        airportNameType airportsName[airportsCount];
        airportCountryType airportsCountry[airportsCount];
        airportIATAType airportsIATA[airportsCount];
        airportICAOType airportsICAO[airportsCount];
        airlineIdType airlinesId[airlinesCount];
        airlineCountryType airlinesCountry[airlinesCount];
        routeAirlineIdType routesAirlineId[routesCount];
        routeSourceAirportIdType routesSourceAirportId[routesCount];
        routeDestinationAirportIdType routesDestinationAirportId[routesCount];

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("space allocating the ten indexes");

        // Building the indexes
        start = high_resolution_clock::now();

        airportsId[airportsCount].dropAnchorCopyKeysSortIndex(airportsId, airportsCount);
        airportsName[airportsCount].dropAnchorCopyKeysSortIndex(airportsName, airportsCount);
        airportsCountry[airportsCount].dropAnchorCopyKeysSortIndex(airportsCountry, airportsCount);
        airportsIATA[airportsCount].dropAnchorCopyKeysSortIndex(airportsIATA, airportsCount);
        airportsICAO[airportsCount].dropAnchorCopyKeysSortIndex(airportsICAO, airportsCount);
        airlinesId[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesId, airlinesCount);
        airlinesCountry[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesCountry, airlinesCount);
        routesAirlineId[routesCount].dropAnchorCopyKeysSortIndex(routesAirlineId, routesCount);
        routesSourceAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesSourceAirportId, routesCount);
        routesDestinationAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesDestinationAirportId, routesCount);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("copying the keys and sorting the ten indexes");
        testTime /= 10;
        displayTime("each index on the average");

        // Creating the relations
        start = high_resolution_clock::now();

        airlineId2RouteAirlineIdType airlineId2RouteAirlineId;
        routeSourceAirportId2AirportIdType routeSourceAirportId2AirportId;
        routeDestinationAirportId2AirportIdType routeDestinationAirportId2AirportId;

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the three relation vectors");

        // Creating the relation vector tuple
        start = high_resolution_clock::now();

        routesJoinRelationsTupleType RoutesJoinRelationsTuple(airlineId2RouteAirlineId, routeSourceAirportId2AirportId, routeDestinationAirportId2AirportId);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the tuple containing the three relation vectors");

        // Creating the query plan
        start = high_resolution_clock::now();

        routesQueryPlanType routesQueryPlan(airlineId2RouteAirlineId, routeSourceAirportId2AirportId, routeDestinationAirportId2AirportId);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the query plan to join the three relation vectors");

        // Creating the joined row array for join output
        start = high_resolution_clock::now();

        const std::size_t routesJoinedRowCount = 70000;
        routesJoinedRowType routesJoinedRow[routesJoinedRowCount];
        routesJoinedRow[0].dropAnchor(&routesQueryPlan);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the joined row array to contain the join output");

        cout << std::string(80, '_') << endl << endl;
        cout << "First, we do ten standard join queries listing the valid routes (possessing valid airlines, from and to airports) for the top ten passenger carriers in the world (as of 2016)." << endl << endl;

        int standardTotalRoutes = 0;
        double standardRangeQueries = 0;

        // Lambda for standard joins
        auto doStandardJoin = [&] (char selectTerm[], char displayText[])
        {
            start = high_resolution_clock::now();
            rangeQueriesStart = rangeQueries;
            int retVal;
            if (!routesQueryPlan.startJoin(selectTerm))
                cout << "Couldn't initialize the validated query for " << displayText << "." << endl << endl;
            else
            {
                retVal = routesJoinedRow[0].join(routesJoinedRowCount);
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                standardJoinTime += testTime;
                totalTime += testTime;
                displayTime(displayText);
                displayRangeQueries();
                standardRangeQueries += rangeQueries - rangeQueriesStart;
                if (retVal >= 0)
                {
                    cout << "Reporting " << retVal << " valid air routes." << endl << endl;
                    standardTotalRoutes += retVal;
                    //printJoin(routesJoinedRow, retVal);
                }
                else
                    cout << "Array size not big enough for " << displayText
                         << " output: more JoinedRows than " << -retVal << endl << endl;
            }
        };

        doStandardJoin((char*)"24", (char*)"American Airlines (199M passengers) join query");
        doStandardJoin((char*)"2009", (char*)"Delta Air Lines (184M passengers) join query");
        doStandardJoin((char*)"4547", (char*)"Southwest Airlines (152M passengers) join query");
        doStandardJoin((char*)"5209", (char*)"United Airlines (143M passengers) join query");
        doStandardJoin((char*)"4296", (char*)"Ryanair/Ireland (120M passengers) join query");
        doStandardJoin((char*)"1767", (char*)"China Southern Airlines (85M passengers) join query");
        doStandardJoin((char*)"1758", (char*)"China Eastern Airlines (81M passengers) join query");
        doStandardJoin((char*)"2297", (char*)"easyJet/UK (73M passengers) join query");
        doStandardJoin((char*)"4951", (char*)"Turkish Airlines (63M passengers) join query");
        doStandardJoin((char*)"3320", (char*)"Lufthansa (62M passengers) join query");
        cout << "Total valid air routes count for the top ten passenger carriers = "
             << standardTotalRoutes << "." << endl;

        displayTime("all ten standard join queries, in total", standardJoinTime);
        cout.precision(0);
        cout << "Using a total of " << standardRangeQueries << " range queries." << endl;

        cout << std::string(80, '_') << endl << endl;
        cout << "Second, we create a full memoized join of all the routes for all airlines in very compact form." << endl << endl;

        // create full memoized join for all routes on all airlines
        start = high_resolution_clock::now();
        rangeQueriesStart = rangeQueries;
        int actualJoinCount;
        if (!routesQueryPlan.startFullMemoizedJoin())
            cout << "Couldn't initialize the validated query." << endl << endl;
        else
        {
            actualJoinCount = routesJoinedRow[0].join(routesJoinedRowCount);
                if (actualJoinCount < 0) throw Output_Array_Size_Not_Big_Enough();
            mergeSortInvoke(routesJoinedRow, actualJoinCount); // faster than quick sort for these ...
            testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
            totalTime += testTime;
            displayTime("full memoized join creation");
            displayRangeQueries();
            if (actualJoinCount >= 0)
            {
                cout << "Full memoized join: valid routes count for all airlines = " << actualJoinCount << endl << endl;
                //printJoin(routesJoinedRow, actualJoinCount);
            }
            else
                cout << "Memoized join array size not big enough for output: more JoinedRows than "
                     << abs(actualJoinCount) << endl << endl;
        }

        cout << std::string(80, '_') << endl << endl;
        cout << "Third, we use that full memoized join to do ten memoized join queries listing the valid routes for the top ten passenger carriers in the world (as of 2016). Note that the numbers of routes are the same as the nested loop joins, but take three orders of magnitude less time, and only one range query for each." << endl << endl;

        int memoizedTotalRoutes = 0;
        double memoizedRangeQueries = 0;

        // Lambda for memoized joins
        auto doMemoizedJoin = [&] (char selectTerm[], char displayText[])
        {
            start = high_resolution_clock::now();
            rangeQueriesStart = rangeQueries;
            int rangeLow = binarySearchRangeLow(routesJoinedRow, actualJoinCount, selectTerm);
            if (rangeLow < 0)
                cout << "No valid air routes for " << displayText << "." << endl << endl;
            else
            {
                int rangeHigh = binarySearchRangeHigh(routesJoinedRow, actualJoinCount, selectTerm);
                int arraySize = rangeHigh - rangeLow + 1;
                routesJoinedRowType outputJoinedRows[arraySize];
                outputJoinedRows[0].dropAnchor(&routesQueryPlan);
                int j = 0;
                for (int i = rangeLow; i <= rangeHigh; i++) outputJoinedRows[j++] = routesJoinedRow[i];
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                memoizedJoinTime += testTime;
                totalTime += testTime;
                displayTime(displayText);
                displayRangeQueries();
                memoizedRangeQueries += rangeQueries - rangeQueriesStart;
                if (arraySize >= 0)
                {
                    cout << "Reporting " << arraySize << " valid air routes." << endl << endl;
                    memoizedTotalRoutes += arraySize;
                    //printJoin(outputJoinedRows, arraySize);
                }
                else throw Logic_Error();
            }
        };

        doMemoizedJoin((char*)"24", (char*)"American Airlines (199M passengers) join query");
        doMemoizedJoin((char*)"2009", (char*)"Delta Air Lines (184M passengers) join query");
        doMemoizedJoin((char*)"4547", (char*)"Southwest Airlines (152M passengers) join query");
        doMemoizedJoin((char*)"5209", (char*)"United Airlines (143M passengers) join query");
        doMemoizedJoin((char*)"4296", (char*)"Ryanair/Ireland (120M passengers) join query");
        doMemoizedJoin((char*)"1767", (char*)"China Southern Airlines (85M passengers) join query");
        doMemoizedJoin((char*)"1758", (char*)"China Eastern Airlines (81M passengers) join query");
        doMemoizedJoin((char*)"2297", (char*)"easyJet/UK (73M passengers) join query");
        doMemoizedJoin((char*)"4951", (char*)"Turkish Airlines (63M passengers) join query");
        doMemoizedJoin((char*)"3320", (char*)"Lufthansa (62M passengers) join query");
        cout << "Total valid air routes count for the top ten passenger carriers = "
             << memoizedTotalRoutes << "." << endl;

        displayTime("all ten memoized join queries, in total", memoizedJoinTime);
        cout.precision(0);
        cout << "Using a total of " << memoizedRangeQueries << " range queries." << endl << endl;

        runTime = duration_cast<duration<double>> (high_resolution_clock::now() - runStart);
        displayStats();

    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl; // the exception name is at the end of the long error string
    }
    return 0;
}

