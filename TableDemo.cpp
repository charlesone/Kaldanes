// Building a table with indexes using Kaldanes

// Please build for release to get good performance

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

  TableDemo.cpp program

  As features were added to this nascent relational database system, the TableDemo program
  exposes that history and it still serves as an eyeball check to see if the latest changes have
  added bugs breaking earlier coding.

  The OpenFlights.org Air Routes Database

  The database used was accessed from the database used by OpenFlights.org. The files contain
  data on all the air routes, airports, and airlines as of 2009, not maintained since. At that
  time there were 65,612 valid air routes (with valid source and destination airports, and
  airlines.) It’s a small database, only 3.5 MB, but you can do big joins on a small database.
  In reference to the relatively small size of database used in the demo programs, the argument
  for whether the current code base will scale to enormous size, has three parts: (1) the index
  sorts are linear time complexity relative to the count of rows while using a small PMNK index
  element, (2) the nested loop joins are linear time complexity relative to the number of output
  joined rows, and also linear relative to the number of range queries, which have an average
  2(log2(n)-1) time complexity for consistent databases, where n is the number of table rows,
  and (3) the memoized join time complexity is effectively constant time. If you think of the
  compile cost as including the memoized join cost, then compiling the relational database
  queries only occurs one time per generation of the database.

  At OpenFlights.org, the data is stored in .dat files, those were converted to .csv files by
  removing quoted strings and replacing commas in those quoted strings with semicolons to
  satisfy the limited .csv input functioning of the current code base. Everything is #-commented
  (R .csv style) in the resulting .csv files presented in the code base.

  The relations between the demo program tables are (1) many airlines serve many airports [m:m],
  (2) routes are flown by one airline + airlines serve many routes [1:m], and (3 and 4) routes
  have one source and destination airport + airports have many source routes [1:m] and many
  destination routes [1:m].
   __________________________________________________________________________________________
  |                                                                                          |
  |                           OpenFlights.org Air Routes Database                            |
  |     ________________                                               ________________      |
  |    |                |_                                           _|                |     |
  |    |                | \                                         / |                |     |
  |    |    Airlines    |----------------- serving [m:m] -------------|    Airports    |     |
  |    |                |_/                                         \_|                |     |
  |    |________________|                                             |________________|     |
  |            |                                                          |       |          |
  |            |                                                         /        |          |
  |            :                            .--- source [m:1] ----------'         |          |
  |             \                          /                                      |          |
  |              \                        /                                       |          |
  |             flying                   |                                        |          |
  |               [1:m]                 /|\                                       |          |
  |                 \            ______|_|_|______                                |          |
  |                  \         _|                 |_                              ;          |
  |                   \       / |                 | \                            /           |
  |                    `--------|     Routes      |------ destination [m:1] ----'            |
  |                           \_|                 |_/                                        |
  |                             |_________________|                                          |
  |                                                                                          |
  |                                                                                          |
  |__________________________________________________________________________________________|

  Once again, the TableDemo program, as all the demo programs do, has two sections before the
  main() function: (1) a Static Metadata Section (SMS) laid out in an absolutely order critical
  way containing everything (classes, types, static data, const and constexpr) that is needed
  for generic programming (compile-time) of the relational database system, and (2) an Active
  Program Section (APS) laid out in whatever order that is desired, in this case containing
  performance analysis declarations and functions, data loading and printing functions, and a
  runtime checker to partially guarantee the consistency of columns versus tables in the layout
  in the SMS.

  All of the elements of the main() function, are executed within an anonymous exception
  handler, that prints out the ugly extended name of the exception with the readable name at the
  end, and that also works in release code for bug analysis during performance testing.

  TableDemo keeps track of the time consumed by operations and printing those operations
  separately, using the nanosecond clock facility of C++11 on Linux. Initially it builds the
  database:

  1.    The three tables are allocated and loaded from .csv files and then anchored into RowString
        arrays.
  2.    Space for the ten indexes on those three tables is allocated.
  3.    The table source anchor is copied into the indexes, the index keys are copied into the
        indexes from the tables, and the indexes are sorted.

  At this point the database is up and ready to query: for the three relational database system
  demos (TableDemo, JoinDemo and BigJoinDemo,) the average time to produce the database and
  bring it up from scratch using input .csv files was 115.556 ms, less than 1/8th of a second.

  First, TableDemo uses a point query lambda to print out the 5 rows centered on a specific
  airport that exists, and one that doesn’t exist, so that it can be shown where it would fit in
  the order of airports. Failed binary searches can be one off the correct location, high or
  low. That small error needs to be corrected for after a range query boundary value binary
  string search which almost always will fail, but be within one of the high or low edge of the
  range where the boundary should have been.

  Second, a range query lambda is executed on the airlines index on the routes table, printing
  all the 378 valid Allegiant Airlines routes. Those are printed out.

  Third, three RelationVector objects are created: (1) an airport relating as source to some
  routes, (2) some routes relating to their destination airport and (3) some routes relating to
  the airline serving them. Then the airport of the first relation’s from-index’s table row and
  the airline of the third relation’s to-index’s table row are printed to make sure everything
  is working.

  Fourth, a tuple is created from the three relation vectors and printing of the same two rows
  above are made to corroborate that that works from the tuple.

  Fifth, a QueryPlan object is created using those three relations in the same order as the
  parameter pack of types. Then, a synthetic JoinedRow is constructed (scaffolding) and printed
  to make sure joined row printing works.

  Sixth, a nested loop join is performed to print out all the valid air routes (having valid
  airlines and destination airports) with Fresno Yosemite Airport as the source airport. There
  are 20 routes in the output, each with four rows printed: source airport, route, destination
  airport and airline. True to the intent: three relation vectors soft-define a joined row with
  four table row’s K-values in it.

  The first two K-values in the joined row element are soft-defined as (1) the from-index table
  row and (2) the to-index table row of the first relation vector and the second two are (3) the
  to-index table rows from the second and (4) the third relation vector, and that would be true
  for any succeeding relation vector. That definition isn’t written down anywhere in code other
  than comments. It arises from the compile time generic programming structure of constants
  generated by the compiler. In other words, C++11 magic constants arise from generic
  programming recursion.

  It is thought that soft-definition of type structure and member function by generic compile
  time programming recursive processing of other template class types is a new and somewhat
  open-ended method of deriving types, only limited by the imagination.

  Finally, a new relation is created from an airport’s country to an airport’s country
  (perfectly legal.) What is not legal is to insert it into a QueryPlan before an airport
  table’s index is included and then try to generate an object from that plan. The final test
  produces a relational linkage exception that is readable on the end to terminate the program.

  Before throwing that exception, the time it took to execute the entire TableDemo program is
  listed:

  1.    Allocating and loading three tables from CSV files on disk = 28,230 microseconds.
  2.    Allocating, copying the keys and sorting ten indexes on those three tables = 92,024
        microseconds.
  3.    Executing multiple point and range query lambdas on the indexes, as a test = 12.500
        microseconds.
  4.    Creating three relation vectors, each containing a from-index and a to-index = 0.907
        microseconds.
  5.    Creating a tuple from those three relation vectors to store the query objects = 0.442
        microseconds.
  6.    Creating and optimizing a database join query plan for those three relation vectors =
        2.239 microseconds.
  7.    Creating a joined row output array and doing a query plan nested loop join into it =
        43.285 microseconds

  All of that building, launching, query planning and generation, and nested loop join querying
  of a relational database from text editor files took 120,314.021 microseconds: less than 1/8
  of a second.

  If a consumer was using mmap to access this relational database as a previously produced slab,
  this execution would be much faster, especially on a memory centric Gen-Z system, or at least
  a 3D XPoint memory. With mmap it would take an estimated 1/100th second to bring up the slab
  database from scratch with one mmap call and execute the various queries in the main() of
  TableDemo. And that would be true of the startup loading of the database from scratch for the
  JoinDemo and BigJoinDemo programs as well.

*/

#include <iostream>
#include <fstream>
#include <climits>
#include <iostream>
#include <stddef.h>
#include <algorithm>
#include <cstring>
#include <tuple>
#include <chrono>

using namespace std;
using namespace std::chrono;

static const bool debugTrace = false;

// Banners from: http://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=Section
// Using ANSI Shadow font

/*
███████╗      ███╗   ███╗        ███████╗
██╔════╝      ████╗ ████║        ██╔════╝
███████╗      ██╔████╔██║        ███████╗
╚════██║      ██║╚██╔╝██║        ╚════██║
███████║tatic ██║ ╚═╝ ██║etadata ███████║ection
╚══════╝      ╚═╝     ╚═╝        ╚══════╝

Goal: What would reside in a database catalog and execute at runtime (compiler, optimizer, etc.)
instead lives in type space and executes at compile time.

Everything in this section (classes, types, static data, const and constexpr)
is needed for generic programming (compile-time)

*/

// Order is critical ...

static const std::size_t maxColumnSizeDefault = 1024;
static const std::size_t pmnkSizeDefault = 0;
typedef int indexIntegerTypeDefault;

enum class Table
{
    airports,
    airlines,
    routes,

    table_Count,
    nilTable = INT_MIN
};
// insert new tables before table_Count, please

static char* charRowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static void* rowAnchors[(int)Table::table_Count] = {0}; // after the first item, the rest get zeroed.
static std::size_t rowCounts[(int)Table::table_Count] = {0}; // ditto, and index length = table length.

enum class Column // must be in the order of Table, above
{
    // 14 airports table columns
    airportId,
    airportName,
    airportCity,
    airportCountry,
    airportIATA,
    airportICAO,
    airportLatitude,
    airportLongitude,
    airportAltitude,
    airportTimezone,
    airportDST,
    airportTz,
    airportType,
    airportSource,

    airportsDivider,

    // 8 airlines table columns
    airlineId,
    airlineName,
    airlineAlias,
    airlineIATA,
    airlineICAO,
    airlineCallsign,
    airlineCountry,
    airlineActive,

    airlinesDivider,

    // 9 routes table columns
    routeAirline,
    routeAirlineId,
    routeSourceAirport,
    routeSourceAirportId,
    routeDestinationAirport,
    routeDestinationAirportId,
    routeCodeshare,
    routeStops,
    routeEquipment,

    routesDivider,

    columnCount, // accessing the array with this enum's static should segfault
    nilColumn = INT_MIN // accessing the array with this enum's static should segfault
};
// insert new columns in order before columnCount,
// please, then adjust the table of IDs below

// Index metadata resides in these (3) arrays
static char* charIndexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static void* indexAnchors[(int)Column::columnCount] = {0}; // after the first item, the rest get zeroed.
static std::size_t indexCounts[(int)Column::columnCount] = {0}; // ditto, and index length = table length.

typedef std::size_t OffsetValue;
static const OffsetValue trammel = UINT_MAX; // to catch the alignment bugs
static const OffsetValue columnId[(int)Column::columnCount + 2] =
// This array translates from the Column enum to the column ID in the specific table.
// THEY NEED TO BE MAINTAINED IN ALIGNMENT!
// "It must be mounted on a tripod!": see "The Wild Bunch" by Peckinpah (director's cut)
// It is effectively the database catalog metadata.
// Use the assertion checker below
// Sorry, this is the only thing I couldn't automate easily and reliably! Variadic templates, later?
{
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,trammel,// 14 valid airports column IDs

    0,1,2,3,4,5,6,7,trammel,// 8 valid airlines column IDs

    0,1,2,3,4,5,6,7,8,trammel,// 9 valid routes column IDs

    trammel,trammel // Everything accessing a trammel as an index should segfault
};

class Improperly_Maintained_columnId_Table : public runtime_error
{
public:
    Improperly_Maintained_columnId_Table() :
        runtime_error("the columnId table relationship to Column enums is broken") {}
};

void columnIdChecker()
{
    if (columnId[(int)Column::airportsDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::airlinesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
    if (columnId[(int)Column::routesDivider] != trammel) throw Improperly_Maintained_columnId_Table();
}

class Invalid_Column_Enum_Class_Member : public runtime_error
{
public:
    Invalid_Column_Enum_Class_Member() :
        runtime_error("the Column enum class element is not a valid member") {}
};

// Had the above gone well this will work fine
constexpr Table column2Table(Column columnEnum)
{
    return (columnEnum < Column::airportsDivider) ? Table::airports
           : (columnEnum < Column::airlinesDivider) ? Table::airlines
           : (columnEnum < Column::routesDivider) ? Table::routes
           : Table::nilTable;
}

#include "RowString.h"
#include "IndexString.h"

const std::size_t airportsMaxLen = 186, airportsColumns = 14, airportsCount = 7184;
const char airportsFile[] = "./airports.csv";
typedef RowString<char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault> airportRow;

const std::size_t airlinesMaxLen = 404, airlinesColumns = 8, airlinesCount = 6162;
const char airlinesFile[] = "./airlines.csv";
typedef RowString<char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault> airlineRow;

const std::size_t routesMaxLen = 65, routesColumns = 9, routesCount = 67663;
const char routesFile[] = "./routes.csv";
typedef RowString<char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault> routeRow;

// Compile time (static) programming is difficult in c++11
template<Column columnEnum>
constexpr decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                   : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                   : (columnEnum < Column::routesDivider) ? (routeRow*)0
                   : (void*)0) column2RowStringPtr()
{
    return (decltype((columnEnum < Column::airportsDivider) ? (airportRow*)0
                     : (columnEnum < Column::airlinesDivider) ? (airlineRow*)0
                     : (columnEnum < Column::routesDivider) ? (routeRow*)0
                     : (void*)0)) (columnEnum < Column::airportsDivider) ? reinterpret_cast<airportRow*>(rowAnchors[(std::size_t)Table::airports])
           : (columnEnum < Column::airlinesDivider) ? reinterpret_cast<airlineRow*>(rowAnchors[(std::size_t)Table::airlines])
           : (columnEnum < Column::routesDivider) ? reinterpret_cast<routeRow*>(rowAnchors[(std::size_t)Table::routes])
           : (void*)0;
}

typedef IndexString<Column::airportId, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airportIdType;
typedef IndexString<Column::airportName, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airportNameType;
typedef IndexString<Column::airportCountry, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airportCountryType;
typedef IndexString<Column::airportIATA, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airportIATAType;
typedef IndexString<Column::airportICAO, char, airportsMaxLen, Table::airports, airportsColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airportICAOType;
typedef IndexString<Column::airlineId, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airlineIdType;
typedef IndexString<Column::airlineCountry, char, airlinesMaxLen, Table::airlines, airlinesColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> airlineCountryType;
typedef IndexString<Column::routeAirlineId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> routeAirlineIdType;
typedef IndexString<Column::routeSourceAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> routeSourceAirportIdType;
typedef IndexString<Column::routeDestinationAirportId, char, routesMaxLen, Table::routes, routesColumns, maxColumnSizeDefault, pmnkSizeDefault, indexIntegerTypeDefault> routeDestinationAirportIdType;

#include "RelationVector.h"

typedef RelationVector<airportIdType, routeSourceAirportIdType> airportId2RouteSourceAirportIdType;
typedef RelationVector<routeDestinationAirportIdType, airportIdType> routeDestinationAirportId2AirportIdType;
typedef RelationVector<routeAirlineIdType, airlineIdType> routeAirlineId2AirlineIdType;
typedef RelationVector<airlineCountryType, airportCountryType> airlineCountry2airportCountryType;

typedef tuple<airportId2RouteSourceAirportIdType, routeDestinationAirportId2AirportIdType, routeAirlineId2AirlineIdType> routesJoinRelationsTupleType;
routesJoinRelationsTupleType relVecsTuple;

// could binary search on c_str from join row offset index -> constexpr auto (c_str) -> returns decltype of index (tuple<n> or variadic)

#include "JoinedRow.h"
typedef QueryPlan<airportId2RouteSourceAirportIdType, routeDestinationAirportId2AirportIdType, routeAirlineId2AirlineIdType> routesQueryPlanType;
typedef JoinedRow<airportId2RouteSourceAirportIdType, routeDestinationAirportId2AirportIdType, routeAirlineId2AirlineIdType> routesJoinedRowType;

typedef QueryPlan<airportId2RouteSourceAirportIdType, airlineCountry2airportCountryType, routeDestinationAirportId2AirportIdType, routeAirlineId2AirlineIdType> routesQueryPlanFailType;


/*
 █████╗       ██████╗   ███████╗
██╔══██╗      ██╔══██╗  ██╔════╝
███████║      ██████╔╝  ███████╗
██╔══██║      ██╔═══╝   ╚════██║
██║  ██║ctive ██║rogram ███████║ection
╚═╝  ╚═╝      ╚═╝       ╚══════╝

Nothing in this section has definitions that the generic programming (compile-time) requires.

*/

// Statistics
duration<double, nano> runTime;
duration<double, nano> testTime;
duration<double, nano> totalTime;

void resetStats()
{
    testTime = duration<double, nano> (0);
    totalTime = duration<double, nano> (0);
}

void displayTime(const char text[])
{
    cout.precision(3);
    cout << "Time for " << text << " = " << fixed << chrono::duration <double, micro> (testTime).count() << " microseconds" << endl;
}

void displayStats()
{
    cout << std::string(80, '_') << endl;
    cout << "Statistics for the run of the program, including:" << endl;
    cout << "   1. Allocating and loading three tables from CSV files on disk, around 80K rows." << endl;
    cout << "   2. Allocating, copying the keys and sorting ten indexes on those three tables." << endl;
    cout << "   3. Executing multiple point and range query lambdas on the indexes, as a test." << endl;
    cout << "   4. Creating three relation vectors, each containing a from-index and a to-index." << endl;
    cout << "   5. Creating a tuple from those three relation vectors to store the query objects." << endl;
    cout << "   6. Creating and optimizing a database join query plan for those three relation vectors." << endl;
    cout << "   7. Creating a joined row output array and doing a query plan nested loop join into it." << endl << endl;
    cout.precision(5);
    cout << "Total run time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> (runTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total relational database system time spent in main() procedure thus far, including I/O = "
         << fixed << chrono::duration <double, micro> (totalTime/1000000).count() << " seconds" << endl << endl;
    cout << "Total display output time spent in main() procedure thus far = "
         << fixed << chrono::duration <double, micro> ((runTime - totalTime)/1000000).count() << " seconds" << endl;
    cout << std::string(80, '_') << endl << endl;
}

class Boolian_Error : public runtime_error
{
public:
    Boolian_Error() :
        runtime_error("boolian operator failure") {}
};

class Could_Not_Open_File : public runtime_error
{
public:
    Could_Not_Open_File() :
        runtime_error("file name could not be opened") {}
};

template<typename T>
void loadCSVFile(T arr[], int size, const char filename[])
{
    ifstream csvFile(filename);
    if (!csvFile)
    {
        throw Could_Not_Open_File();
    }
    for (int i = 0; (csvFile) && i <= size; i++)
    {
        char input;
        csvFile >> input;
        if (input == '#') // pass over R Language comment lines beginning with a '#'
        {
            csvFile.ignore(numeric_limits<streamsize>::max(), '\n');
            i--;
        }
        else
        {
            csvFile.putback(input);
            csvFile >> arr[i];
        }
    }
    csvFile.close();
}

class Type_Not_Supported_Here : public runtime_error
{
public:
    Type_Not_Supported_Here() :
        runtime_error("that type is not supported in this function") {}
};

template<typename T>
void printIndex(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++) cout << *(arr[i].row()) << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printTable(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isRowString[] = "RowString";
    if (strstr(typeName.c_str(), isRowString))
    {
        for (int i = 0; i < size; i++) cout << arr[i] << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printJoin(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isJoinedRow[] = "JoinedRow";
    if (strstr(typeName.c_str(), isJoinedRow))
    {
        for (int i = 0; i < size; i++)
        {
            cout << std::string(133, '-') << endl;
            arr[i].print();
        }
        cout << std::string(133, '-') << endl << endl;
    }
    else throw Type_Not_Supported_Here();
}

template<typename T>
void printIndexColumn(T arr[], int size)
{
    typedef typename std::remove_reference<T>::type TR;
    string typeName = typeid(TR).name();
    char isIndexString[] = "IndexString";
    if (strstr(typeName.c_str(), isIndexString))
    {
        // probably should list the friend classes first, in case of detailed demangling
        for (int i = 0; i < size; i++)
        {
            cout << arr[i] << endl;
//            cout << arr[i];
//            if (i + 1 < size) cout << " ";
//            else cout << endl;
        }
    }
    else throw Type_Not_Supported_Here();
}

void asserts()
{
    columnIdChecker();
}

int main()
{
    cout << endl << endl << "[Note: Remember to set the C++11 switch in the IDE or compiler!" << endl << endl
         << " Remember to use release builds if you are analyzing performance," << endl
         << "   otherwise Index builds will be very slow!" << endl << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited," <<endl
         << "   otherwise it can die!]" << endl;

    //airports, airlines, routes
    try
    {
        // Anonyomous catch -> exception names in release code execution

        asserts();

        // Tables

        high_resolution_clock::time_point runStart = high_resolution_clock::now();

        high_resolution_clock::time_point start = high_resolution_clock::now();

        airportRow airports[airportsCount];
        airports[0].dropAnchor(airports, airportsCount);
        loadCSVFile(airports, airportsCount, airportsFile);

        airlineRow airlines[airlinesCount];
        airlines[0].dropAnchor(airlines, airlinesCount);
        loadCSVFile(airlines, airlinesCount, airlinesFile);

        routeRow routes[routesCount];
        routes[0].dropAnchor(routes, routesCount);
        loadCSVFile(routes, routesCount, routesFile);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        cout << endl << endl;
        displayTime("space allocating and loading the three tables from CSV files");

        // Index space allocation

        start = high_resolution_clock::now();

        airportIdType airportsId[airportsCount];
        airportNameType airportsName[airportsCount];
        airportCountryType airportsCountry[airportsCount];
        airportIATAType airportsIATA[airportsCount];
        airportICAOType airportsICAO[airportsCount];
        airlineIdType airlinesId[airlinesCount];
        airlineCountryType airlinesCountry[airlinesCount];
        routeAirlineIdType routesAirlineId[routesCount];
        routeSourceAirportIdType routesSourceAirportId[routesCount];
        routeDestinationAirportIdType routesDestinationAirportId[routesCount];

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("space allocating the ten indexes");

        // Building the indexes

        start = high_resolution_clock::now();

        airportsId[airportsCount].dropAnchorCopyKeysSortIndex(airportsId, airportsCount);
        airportsName[airportsCount].dropAnchorCopyKeysSortIndex(airportsName, airportsCount);
        airportsCountry[airportsCount].dropAnchorCopyKeysSortIndex(airportsCountry, airportsCount);
        airportsIATA[airportsCount].dropAnchorCopyKeysSortIndex(airportsIATA, airportsCount);
        airportsICAO[airportsCount].dropAnchorCopyKeysSortIndex(airportsICAO, airportsCount);
        airlinesId[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesId, airlinesCount);
        airlinesCountry[airlinesCount].dropAnchorCopyKeysSortIndex(airlinesCountry, airlinesCount);
        routesAirlineId[routesCount].dropAnchorCopyKeysSortIndex(routesAirlineId, routesCount);
        routesSourceAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesSourceAirportId, routesCount);
        routesDestinationAirportId[routesCount].dropAnchorCopyKeysSortIndex(routesDestinationAirportId, routesCount);

        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("copying the keys and sorting the ten indexes");
        testTime /= 10;
        displayTime("each index on the average");

        cout << endl << "First, let's execute a point query lambda on the airportsName index, for an airport that exists, and one that is imaginary." << endl << endl;

        int rowIndex;
        airportNameType* airportNamePtr;
        routeAirlineIdType* routesAirlinePtr;

        auto printAirports = [&] (string name, std::size_t count = 5)
        {
            start = high_resolution_clock::now();
            rowIndex = binarySearch(airportsName, airportsCount, name.c_str());
            testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
            totalTime += testTime;
            displayTime("a point query on an index on a smaller table");
            cout << endl;
            airportNamePtr = airportsName + abs(rowIndex) - 2;
            cout << "\"" << name << "\" Airport record query:" << endl;
            cout << "Returns: " << rowIndex << ((rowIndex < 0) ? " (Missing)" : " (Existing)") << endl;
            cout << std::string(165, '-') << endl;
            printIndex(airportNamePtr, count);
            cout << std::string(165, '-') << endl;
        };

        printAirports("La Guardia Airport");
        cout << endl;
        printAirports("La Nunca Airport");

        cout << endl << "Second, let's execute a range query lambda on the routesAirlineId index, printing all Allegiant Airlines (AAY, ID=35) routes." << endl << endl;

        int rangeLowRowIndex;
        int rangeHighRowIndex;

        auto printRoutesAirlinesRange = [&] (string name)
        {
            start = high_resolution_clock::now();
            rangeLowRowIndex = binarySearchRangeLow(routesAirlineId, routesCount, name.c_str());
            routesAirlinePtr = routesAirlineId + abs(rangeLowRowIndex);
            rangeHighRowIndex = binarySearchRangeHigh(routesAirlineId, routesCount, name.c_str());
            testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
            totalTime += testTime;
            displayTime("a range query on an index on the biggest table (70K records)");
            cout << endl;
            cout << "\"" << name << "\" Routes record range query:" << endl;
            cout << "Returns: " << rangeLowRowIndex << ((rangeLowRowIndex < 0) ? " (Missing)" : " (Existing)") << endl;
            cout << std::string(35, '-') << endl;
            printIndex(routesAirlinePtr, rangeHighRowIndex - rangeLowRowIndex + 1);
            cout << std::string(35, '-') << endl;
        };

        printRoutesAirlinesRange("35");

        cout << endl << "Third, let's make three relation vectors with 'from' and 'to' indexes for each, and see that we can print some table rows from there." << endl << endl;

        start = high_resolution_clock::now();
        airportId2RouteSourceAirportIdType airportId2RouteSourceAirportId;
        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        cout << "Relation Vector airportId2RouteSourceAirportId.fromIndex[24]: " << endl << std::string(133, '-') << endl;
        cout << ((airportId2RouteSourceAirportId.fromIndex())->row())[23];
        cout << endl << std::string(133, '-') << endl;
        cout << "Relation Vector airportId2RouteSourceAirportId byte size: " << sizeof(airportId2RouteSourceAirportId) << endl << endl;

        start = high_resolution_clock::now();
        routeDestinationAirportId2AirportIdType routeDestinationAirportId2AirportId;

        routeAirlineId2AirlineIdType routeAirlineId2AirlineId;
        testTime += duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        cout << "Relation Vector routeAirlineId2AirlineId.toIndex[15]: " << endl << std::string(43, '-') << endl;
        cout << ((routeAirlineId2AirlineId.toIndex())->row())[15];
        cout << endl << std::string(43, '-') << endl;
        displayTime("creating the three relation vectors");


        cout << endl << "Fourth, let's make a tuple of three relation vectors that will form a join, and see that we can print the same table rows from there." << endl << endl;

        start = high_resolution_clock::now();
        routesJoinRelationsTupleType RoutesJoinRelationsTuple(airportId2RouteSourceAirportId, routeDestinationAirportId2AirportId, routeAirlineId2AirlineId);
        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the tuple containing the three relation vectors");
        cout << endl;
        cout << "Routes Join relation tuple<0> 'from' airportId2RouteSourceAirportId.fromIndex[24] (same as above): " << endl << std::string(133, '-') << endl;
        cout << ((get<0>(RoutesJoinRelationsTuple).fromIndex())->row())[23];
        cout << endl << std::string(133, '-') << endl << endl;
        cout << "Routes Join relation tuple<2> 'to' routeAirlineId2AirlineId.toIndex[15] (same as above): " << endl << std::string(43, '-') << endl;
        cout << ((get<2>(RoutesJoinRelationsTuple).toIndex())->row())[15];
        cout << endl << std::string(43, '-') << endl;
        cout << "Routes Join relation tuple byte size: " << sizeof(RoutesJoinRelationsTuple) << endl;

        cout << endl << "Fifth, let's make a linked (and checked) QueryPlan of the joined row tables from the relation vectors (which makes a tuple called relVecsTuple), and see if we can access a madeup joined route (SJC->LAS) from the JoinedRow." << endl <<  endl;

        start = high_resolution_clock::now();
        routesQueryPlanType routesQueryPlan(airportId2RouteSourceAirportId, routeDestinationAirportId2AirportId, routeAirlineId2AirlineId);
        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the query plan to join the three relation vectors");
        cout << endl;
        cout << "Query Plan for routes byte size: " << sizeof(routesQueryPlan) << endl << endl;

        start = high_resolution_clock::now();
        const std::size_t routesJoinedRowCount = 100;
        routesJoinedRowType routesJoinedRow[routesJoinedRowCount];
        routesJoinedRow[0].dropAnchor(&routesQueryPlan);
        testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        totalTime += testTime;
        displayTime("creating the joined row array to contain the join output");
        cout << endl;

        cout << std::string(171, '-') << endl;
        routesJoinedRow[0].joinedRowPrintTest();
        cout << std::string(171, '-') << endl;

        cout << "Routes JoinedRow byte size: " << sizeof(routesJoinedRow[0]) << endl;

        cout << endl << "Sixth, let's try a nested loop join listing all the valid air routes (having valid airlines, in or out airports) out of the Fresno Yosemite Airport" << endl <<  endl;

        {
            start = high_resolution_clock::now();
            char selectTerm[] = "3687";
            int retVal;
            if (!routesQueryPlan.startJoin(selectTerm))
                cout << "Couldn't initialize the validated query." << endl << endl;
            else
            {
                retVal = routesJoinedRow[0].join(routesJoinedRowCount);
                testTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
                totalTime += testTime;
                displayTime("doing the four table join");
                cout << endl;
                if (retVal >= 0)
                {
                    cout << "return count = " << retVal << endl;
                    printJoin(routesJoinedRow, retVal);
                }
                else
                    cout << "Array size not big enough for output: more JoinedRows than " << -retVal << endl << endl;
            }
        }

        runTime = duration_cast<duration<double>> (high_resolution_clock::now() - runStart);

        displayStats();

        cout << "Finally, let's make a linked (and checked) QueryPlan of the joined row tables with one extra relation vector, that violates the linkage rule: that every from-index (after the first one) has a preceding to-indexed or initial from-indexed table to link from. The query plan checker should throw  an exception (exception name at end of error string)." << endl <<  endl;

        airlineCountry2airportCountryType airlineCountry2airportCountry;

        routesQueryPlanFailType routesQueryPlanFail(airportId2RouteSourceAirportId, airlineCountry2airportCountry, routeDestinationAirportId2AirportId, routeAirlineId2AirlineId);

    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl; // the exception name is at the end of the long error string
    }
    return 0;
}

