// three different string types: sorting time comparison

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

*/

#include <iostream>
#include <chrono>
#include <string.h>
#include <algorithm>
#include "Direct.h"
#include "Symbiont.h"
#include "Head.h"
#include "Sorts.h"

using namespace std;
using namespace std::chrono;

// Only calls distribution(generator) on the average, one time for every four characters.
// Should be faster than calling it on every character, I think
template<typename T, typename U, typename V>
void generateRandomStrings(T tArr[], U uArr[], V vArr[], int sizeArray, int sizeString)
{
    char radixString[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    const int radixLen = sizeof(radixString) - 1; // it's null-terminated
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine generator(seed);
    std::uniform_int_distribution<unsigned long long>
    distribution(numeric_limits<unsigned long long>::min(), numeric_limits<unsigned long long>::max());
    int uint64Length = sizeString/8 + 1; // rounding up to having more than enough random bits
    if (sizeString%8 == 0) --uint64Length; // rounding back the even cases to just enough bits
    union byteRand
    {
        uint64_t uint64Rand[128];
        uint8_t  uint8Rand[1024];
        char     charRand[1025];
    };
    byteRand overlay;

    for (int i = 0; i < sizeArray; ++i)
    {
        for (int j = 0; j < uint64Length; ++j)
        {
            overlay.uint64Rand[j] = distribution(generator);
        }
        for (int j = 0; j < sizeString; ++j)
        {
            overlay.uint8Rand[j] = radixString[overlay.uint8Rand[j] % radixLen];
        }
        overlay.charRand[sizeString] = 0;
        tArr[i].reserve(sizeString);
        tArr[i].assign(overlay.charRand);
        uArr[i].reserve(sizeString);
        uArr[i].assign(overlay.charRand);
        vArr[i].reserve(sizeString);
        vArr[i].assign(overlay.charRand);
    }
}

double lCompares, llCompares;
double lSwaps, llSwaps;

class Array_Not_Sorted : public runtime_error
{
public:
    Array_Not_Sorted() :
        runtime_error("Array items are not in sorted order") {}
};

template<typename T>
void throwExceptionIfUnsorted(T arr[], int size)
{
    for (int i = 1; i < size; ++i)
    {
        if (arr[i - 1] > arr[i])
        {
            throw Array_Not_Sorted();
        }
    }
}

class Boolian_Error : public runtime_error
{
public:
    Boolian_Error() :
        runtime_error("boolian operator failure") {}
};

template<typename T>
void throwExceptionIfNotBoolian(T arr[], int size)
{
    // test if the boolian operators work correctly against random arrays
    for (int i = 1; i < size; ++i)
    {
        bool lt = (arr[i - 1] < arr[i]);
        bool le = (arr[i - 1] <= arr[i]);
        bool eq = (arr[i - 1] == arr[i]);
        bool ne = (arr[i - 1] != arr[i]);
        bool ge = (arr[i - 1] >= arr[i]);
        bool gt = (arr[i - 1] > arr[i]);

        // mutual exclusion
        if (lt && eq) throw Boolian_Error();
        if (lt && gt) throw Boolian_Error();
        if (eq && gt) throw Boolian_Error();
        if (le && gt) throw Boolian_Error();
        if (ge && lt) throw Boolian_Error();
        if (eq && ne) throw Boolian_Error();

        // mutual inclusion
        if (le && !(lt || eq)) throw Boolian_Error();
        if (ge && !(gt || eq)) throw Boolian_Error();
        if (ne && !(lt || gt)) throw Boolian_Error();
    }
}

template<typename T>
void display(T arr[], int size)
{
    cout.precision(1);
    for (int i = 0; i < size; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
}

const int shortStrings = 10;
const int mediumStrings = 100;
const int longStrings = 1000;

const int smallArrays = 100;
const int largeArrays = 10000;
const int giantArrays = 1000000;

const std::size_t pmnkSize = 1; // Guarantees running off to the tail string a lot.
const std::size_t switchoverPmnkSize = 1; // Guarantees running off to the tail string a lot.

template<typename T>
void doQuick(T arr[], int size, string type)
{
    llCompares = lCompares;
    lCompares = compares;
    compares = 0;
    llSwaps = lSwaps;
    lSwaps = swaps;
    swaps = 0;
    duration<double, nano> sortTime = duration<double, nano> (0);
    high_resolution_clock::time_point start = high_resolution_clock::now();
    quickSortInvoke(arr, size);
    sortTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
    throwExceptionIfUnsorted(arr, size);
    cout.precision(3);
    cout << fixed << type << ": " << chrono::duration <double, micro> (sortTime).count() << " microseconds, "
         << swaps << " swaps, " << compares << " compares" << endl;
}

template<typename T>
void doMerge(T arr[], int size, string type)
{
    llCompares = lCompares;
    lCompares = compares;
    compares = 0;
    llSwaps = lSwaps;
    lSwaps = swaps;
    swaps = 0;
    duration<double, nano> sortTime = duration<double, nano> (0);
    high_resolution_clock::time_point start = high_resolution_clock::now();
    mergeSortInvoke(arr, size);
    sortTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
    throwExceptionIfUnsorted(arr, size);
    cout.precision(3);
    cout << fixed << type << ": " << chrono::duration <double, micro> (sortTime).count() << " microseconds, "
         << swaps << " swaps, " << compares << " compares" << endl << flush;
}

class Sort_Comparator_Failure : public runtime_error
{
public:
    Sort_Comparator_Failure() :
        runtime_error("identical Direct, Symbiont and Head arrays should sort identically") {}
};

void doThreeShortQuick(int size)
{
    //string strArr[size];
    Direct<char, shortStrings> dirArr[size];

    Symbiont<shortStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<shortStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail


    generateRandomStrings(dirArr, symArr, headArr, size, shortStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " short strings (10 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeShortMerge(int size)
{
    //string strArr[size];
    Direct<char, shortStrings> dirArr[size];

    Symbiont<shortStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<shortStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, shortStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " short strings (10 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeMediumQuick(int size)
{
    //string strArr[size];
    Direct<char, mediumStrings> dirArr[size];

    Symbiont<mediumStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<mediumStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, mediumStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " medium strings (100 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeMediumMerge(int size)
{
    //string strArr[size];
    Direct<char, mediumStrings> dirArr[size];

    Symbiont<mediumStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<mediumStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, mediumStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " medium strings (100 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeLongQuick(int size)
{
    //string strArr[size];
    Direct<char, longStrings> dirArr[size];

    Symbiont<longStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<longStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, longStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " long strings (1000 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeLongMerge(int size)
{
    //string strArr[size];
    Direct<char, longStrings> dirArr[size];

    Symbiont<longStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<longStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, longStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " long strings (1000 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

int main()
{
    cout << endl << endl << "Three different string types, identical in content and "
         << "sorting logic, but not in timings." << endl << endl
         << "[Remember to set the C++11 switch in the IDE or compiler!" << endl
         << " Remember to use release builds if you are analyzing performance, otherwise Symbionts very slow!" << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited, otherwise it dies!]" << endl << endl;
    try // so you can see the exception names in release code execution
    {
        do
        {
            doThreeShortQuick(smallArrays);
            doThreeShortMerge(smallArrays);
            doThreeMediumQuick(smallArrays);
            doThreeMediumMerge(smallArrays);
            doThreeLongQuick(smallArrays);
            doThreeLongMerge(smallArrays);
            doThreeShortQuick(largeArrays);
            doThreeShortMerge(largeArrays);
            doThreeMediumQuick(largeArrays);
            doThreeMediumMerge(largeArrays);
            doThreeLongQuick(largeArrays);
            doThreeLongMerge(largeArrays);
            doThreeShortQuick(giantArrays);
            doThreeShortMerge(giantArrays);
            doThreeMediumQuick(giantArrays);
            doThreeMediumMerge(giantArrays);
            doThreeLongQuick(giantArrays);
            doThreeLongMerge(giantArrays);
        }
        while (true);
    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl;
    }
    return 0;
}
