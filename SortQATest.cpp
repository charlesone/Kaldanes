// three different string types: sorting time comparison

/* Please build for release to get good performance
   Remember to set 'ulimit -s unlimited' to set the soft and hard stack limits to unlimited,
   otherwise programs will die in startup!
*/

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

  Caveat: these are single-threaded sorting comparisons. Multi-threading,
  distribution, and best sorting algorithm are a separate exercise. Having the
  fastest strings on the fastest containers makes for the fastest single threaded
  sorting, independent of the algorithm, distribution and the parallelization. Slow
  components are not worthy of fast algorithms and excellent distributed
  parallelization.

  SortQATest is a program in the Kaldanes GitHub code base:
  https://github.com/charlesone/Kaldanes

  All files concerned are located in there and can be built by the “make all”
  command (including the header files Direct.h, Symbiont.h, Head.h, and Sorts.h).

  SortQATest is a C++11 Linux console program churning out performance output
  statistics line-by-line to the console. It does performance analysis using the
  precision nanosecond clock support from C++11 on Linux. SortQATest has not yet
  been run on Windows.

  Four types of 8-byte strings are tested against the same template quick sort
  functions, and next plot, merge sort: (1) std::string class objects are provided
  by C++ libraries and have the ability to be shared with copy-on-write support for
  threading, so moving them is by pointer, (2) Direct template class strings, which
  move as a single element during sorting, (3) Symbiont template class strings,
  which are stored in a block with a head and a body, such that during sorting the
  heads move and the bodies stay in place, and (4) Head template class strings
  which have their heads stored in a separate array, and which declare a Direct
  array internally to store the bodies which don’t move.

  A generically interesting thing is how random strings are generated for the
  SortQATest program. The number of calls to the random bits generation is reduced
  by an average of four across different string lengths. This was done by
  generating them 64 bits wide at a time into a char overlay. No comparisons were
  done, but it is mighty fast.

  SortQATest was taken from the source for SortDemo, with the std::strings
  removed (they take too long.) SortQATest throws an exception if the three
  string classes produce different numbers of compares and swaps from sorting the
  identical string arrays using the identical code. Also, since merge sort only
  uses the <= comparison, and quick sort only uses the < and the > comparisons on
  the actual data (not integer indexes), for coverage it was decided to walk the
  sorted arrays with all possible Boolean combinations to test all of the
  comparison functions, comparing both the previous and successive array element
  against the current one, for consistency against the sorted random data, and
  this caught some subtle bugs. The pmnk (poor man’s normalized key) compare
  logic is complex and highly optimized to never, ever go to compare the tail
  string if the result can be deduced from the pmnk head string. Comparisons with
  self, or a pivot copy of self, reduce to K-value equality. SortQATest runs
  forever and the output looks like SortDemo.

*/

#define __STDC_WANT_LIB_EXT1__ 1
#include <iostream>
#include <chrono>
#include <random>
#include <string.h>
#include <algorithm>
#include <climits>
#include "Direct.h"
#include "Symbiont.h"
#include "Head.h"

static const bool debugTrace = false;

#include "Sorts.h"

using namespace std;
using namespace std::chrono;

// Only calls distribution(generator) on the average, one time for every four characters.
// Should be faster than calling it on every character, I think
template<typename T, typename U, typename V>
void generateRandomStrings(T tArr[], U uArr[], V vArr[], int sizeArray, int sizeString)
{
    char radixString[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    const int radixLen = sizeof(radixString) - 1; // it's null-terminated
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine generator(seed);
    std::uniform_int_distribution<unsigned long long>
    distribution(numeric_limits<unsigned long long>::min(), numeric_limits<unsigned long long>::max());
    int uint64Length = sizeString/8 + 1; // rounding up to having more than enough random bits
    if (sizeString%8 == 0) --uint64Length; // rounding back the even cases to just enough bits
    union byteRand
    {
        uint64_t uint64Rand[128];
        uint8_t  uint8Rand[1024];
        char     charRand[1025];
    };
    byteRand overlay;

    for (int i = 0; i < sizeArray; ++i)
    {
        for (int j = 0; j < uint64Length; ++j)
        {
            overlay.uint64Rand[j] = distribution(generator);
        }
        for (int j = 0; j < sizeString; ++j)
        {
            overlay.uint8Rand[j] = radixString[overlay.uint8Rand[j] % radixLen];
        }
        overlay.charRand[sizeString] = 0;
        tArr[i].reserve(sizeString);
        tArr[i].assign(overlay.charRand);
        uArr[i].reserve(sizeString);
        uArr[i].assign(overlay.charRand);
        vArr[i].reserve(sizeString);
        vArr[i].assign(overlay.charRand);
    }
}

double lCompares, llCompares;
double lSwaps, llSwaps;

class Array_Not_Sorted : public runtime_error
{
public:
    Array_Not_Sorted() :
        runtime_error("Array items are not in sorted order") {}
};

template<typename T>
void throwExceptionIfUnsorted(T arr[], int size)
{
    for (int i = 1; i < size; ++i)
    {
        if (arr[i - 1] > arr[i])
        {
            throw Array_Not_Sorted();
        }
    }
}

class Boolian_Error : public runtime_error
{
public:
    Boolian_Error() :
        runtime_error("boolian operator failure") {}
};

template<typename T>
void throwExceptionIfNotBoolian(T arr[], int size)
{
    // test if the boolian operators work correctly against random arrays
    for (int i = 1; i < size; ++i)
    {
        bool lt = (arr[i - 1] < arr[i]);
        bool le = (arr[i - 1] <= arr[i]);
        bool eq = (arr[i - 1] == arr[i]);
        bool ne = (arr[i - 1] != arr[i]);
        bool ge = (arr[i - 1] >= arr[i]);
        bool gt = (arr[i - 1] > arr[i]);

        // mutual exclusion
        if (lt && eq) throw Boolian_Error();
        if (lt && gt) throw Boolian_Error();
        if (eq && gt) throw Boolian_Error();
        if (le && gt) throw Boolian_Error();
        if (ge && lt) throw Boolian_Error();
        if (eq && ne) throw Boolian_Error();

        // mutual inclusion
        if (le && !(lt || eq)) throw Boolian_Error();
        if (ge && !(gt || eq)) throw Boolian_Error();
        if (ne && !(lt || gt)) throw Boolian_Error();
    }
}

template<typename T>
void display(T arr[], int size)
{
    cout.precision(1);
    for (int i = 0; i < size; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
}

const int shortStrings = 10;
const int mediumStrings = 100;
const int longStrings = 1000;

const int smallArrays = 100;
const int largeArrays = 10000;
const int giantArrays = 1000000;

const std::size_t pmnkSize = 1; // Guarantees running off to the tail string a lot.
const std::size_t switchoverPmnkSize = 1; // Guarantees running off to the tail string a lot.

template<typename T>
void doQuick(T arr[], int size, string type)
{
    llCompares = lCompares;
    lCompares = compares;
    compares = 0;
    llSwaps = lSwaps;
    lSwaps = swaps;
    swaps = 0;
    duration<double, nano> sortTime = duration<double, nano> (0);
    high_resolution_clock::time_point start = high_resolution_clock::now();
    quickSortInvoke(arr, size);
    sortTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
    throwExceptionIfUnsorted(arr, size);
    cout.precision(3);
    cout << fixed << type << ": " << chrono::duration <double, micro> (sortTime).count() << " microseconds, "
         << swaps << " swaps, " << compares << " compares" << endl;
}

template<typename T>
void doMerge(T arr[], int size, string type)
{
    llCompares = lCompares;
    lCompares = compares;
    compares = 0;
    llSwaps = lSwaps;
    lSwaps = swaps;
    swaps = 0;
    duration<double, nano> sortTime = duration<double, nano> (0);
    high_resolution_clock::time_point start = high_resolution_clock::now();
    mergeSortInvoke(arr, size);
    sortTime = duration_cast<duration<double>> (high_resolution_clock::now() - start);
    throwExceptionIfUnsorted(arr, size);
    cout.precision(3);
    cout << fixed << type << ": " << chrono::duration <double, micro> (sortTime).count() << " microseconds, "
         << swaps << " swaps, " << compares << " compares" << endl << flush;
}

class Sort_Comparator_Failure : public runtime_error
{
public:
    Sort_Comparator_Failure() :
        runtime_error("identical Direct, Symbiont and Head arrays should sort identically") {}
};

void doThreeShortQuick(int size)
{
    //string strArr[size];
    Direct<char, shortStrings> dirArr[size];

    Symbiont<shortStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<shortStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail


    generateRandomStrings(dirArr, symArr, headArr, size, shortStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " short strings (10 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeShortMerge(int size)
{
    //string strArr[size];
    Direct<char, shortStrings> dirArr[size];

    Symbiont<shortStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<shortStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, shortStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " short strings (10 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeMediumQuick(int size)
{
    //string strArr[size];
    Direct<char, mediumStrings> dirArr[size];

    Symbiont<mediumStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<mediumStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, mediumStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " medium strings (100 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeMediumMerge(int size)
{
    //string strArr[size];
    Direct<char, mediumStrings> dirArr[size];

    Symbiont<mediumStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<mediumStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, mediumStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " medium strings (100 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeLongQuick(int size)
{
    //string strArr[size];
    Direct<char, longStrings> dirArr[size];

    Symbiont<longStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<longStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, longStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Quick Sort " << size << " long strings (1000 bytes)" << endl;
    doQuick(dirArr, size, "Direct");
    doQuick(symArr, size, "Symbiont");
    doQuick(headArr, size, "Head");
    //doQuick(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

void doThreeLongMerge(int size)
{
    //string strArr[size];
    Direct<char, longStrings> dirArr[size];

    Symbiont<longStrings, pmnkSize, switchoverPmnkSize> symArr[size];
    symArr[0].dropAnchorKInit(symArr, size); // Extra work for Kaldane Symbiont

    typedef Head<longStrings, pmnkSize, switchoverPmnkSize> head;
    head headArr[size];
    head::tail tailArr[size];
    headArr[0].dropAnchorKInit(headArr, tailArr, size); // Extra work for Kaldane Head and Direct tail

    generateRandomStrings(dirArr, symArr, headArr, size, longStrings);
    throwExceptionIfNotBoolian(symArr, size);
    throwExceptionIfNotBoolian(headArr, size);
    cout << endl << "Merge Sort " << size << " long strings (1000 bytes)" << endl;
    doMerge(dirArr, size, "Direct");
    doMerge(symArr, size, "Symbiont");
    doMerge(headArr, size, "Head");
    //doMerge(strArr, size, "<string>");
    if (!(compares == lCompares && lCompares == llCompares && swaps == lSwaps && lSwaps == llSwaps)) throw Sort_Comparator_Failure();
}

int main()
{
    cout << endl << endl << "Three different string types, identical in content and" << endl
         << "sorting logic, but not in timings." << endl << endl
         << "[Note that the number of swaps and compares for identical arrays," << endl
         << "   using the identical code: these statistics should be identical." << endl << endl
         << " Remember to set the C++11 switch in the IDE or compiler!" << endl << endl
         << " Remember to use release builds if you are analyzing performance," << endl
         << "   otherwise Symbionts will be very slow!" << endl << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited," <<endl
         << "   otherwise it can die!]" << endl << endl;
    try // so you can see the exception names in release code execution
    {
        do
        {
            doThreeShortQuick(smallArrays);
            doThreeShortMerge(smallArrays);
            doThreeMediumQuick(smallArrays);
            doThreeMediumMerge(smallArrays);
            doThreeLongQuick(smallArrays);
            doThreeLongMerge(smallArrays);
            doThreeShortQuick(largeArrays);
            doThreeShortMerge(largeArrays);
            doThreeMediumQuick(largeArrays);
            doThreeMediumMerge(largeArrays);
            doThreeLongQuick(largeArrays);
            doThreeLongMerge(largeArrays);
            doThreeShortQuick(giantArrays);
            doThreeShortMerge(giantArrays);
            doThreeMediumQuick(giantArrays);
            doThreeMediumMerge(giantArrays);
            doThreeLongQuick(giantArrays);
            doThreeLongMerge(giantArrays);
        }
        while (true);
    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl;
    }
    return 0;
}
