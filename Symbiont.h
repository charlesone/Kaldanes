#ifndef SYMBIONT_H_INCLUDED
#define SYMBIONT_H_INCLUDED

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

Symbiont.h - header file for Kaldane Symbiont string, which are variable-length (with an upper
  bound) null-terminated byte strings that have their indexes and a "poor man's normalized key"
  (pmnk) moved when they are swapped, without moving their tail strings (ignoring the Sort Benchmark
  rules). Symbiont has "value-string semantics" as Stroustrup defined for his String type (C++11,
  chapter 19.3) These might be a candidate for the Indy Sort. Symbiont strings behave like Direct
  strings for short lengths (32 bytes or less, by internally equating the pmnk length with the
  string length.) This allows Symbiont strings to match Direct strings in performance for short
  strings and still have constant time complexity for any string length: they are a candidate
  for general purpose string programming with stack slab allocation/deallocation as opposed to
  the fine-grained allocators, which are necessary for pointer strings like <string>. Symbiont
  strings are quadratic in the debug build for  merge sort, and linear in the release build for
  both quick sort and merge sort, so remember to use the release build for performance analysis.
  They are designed to be used  with with slab allocation/deallocation on the stack, as opposed
  to fine-grained allocators. Since the allocated slab never needs to contain pointers, only
  array indices, the slab data structure is base+offset and can be mmapped to a file or /dev/shm
  and shared locally or across a memory fabric such as Gen-Z, or stored and transmitted, or mmapped
  over an NFS: consistency considerations are an issue for sharing, of course (caveat participem).

  The name Kaldane is an antique SciFi reference (heads move, bodies stay):
  http://www.catspawdynamics.com/images/gino_d%27achille_5-the_chessmen_of_mars.jpg
  or google image search the word "kaldane"
  https://en.wikipedia.org/wiki/Kaldane

*/

#include <iostream>

using namespace std;

static char *strAnchor = 0;

template <std::size_t maxStringSize, std::size_t maxPmnkSize = 3, std::size_t switchoverPmnkSize = 32>
class Symbiont
{
private:

    //static_assert(maxStringSize > 0, "maxStringSize must be positive"); // can't get this to work
    //static_assert(maxPmnkSize <= maxStringSize, "maxPmnkSize must be <= maxStringSize"); // can't get this to work

    static const std::size_t headPlusTailLen = maxStringSize;
    // if maxStringSize <= switchoverPmnkSize, the pmnk will contain the whole string
    static const std::size_t optimalMaxPmnkSize = (headPlusTailLen <= switchoverPmnkSize
                                                    && maxPmnkSize <= switchoverPmnkSize)
                                                    ? headPlusTailLen : maxPmnkSize;
    // The mechanism is driven from the maxPmnkSize choice, see the quote below. If prefix truncation cannot
    // be done reasonably, then increase this to minimize the occurrence of going to the tail string.
    // Try to make the PMNK string + null fit in an integer (4-byte) package, struct round-off by the compiler
    // will take that space anyway: Optimal sizes are 3,7,11,15,19 ...
    // Also, through looking at the performance of Direct strings (moving all of it, not just the head),
    // it turns out to be faster, for strings 32 bytes or less, to make the pmnk the size of the string and
    // have an empty tail: hence the optimalMaxPmnkSize. This is possibly due to striding pre-fetch, I think.
    static const std::size_t pmnkSize = (headPlusTailLen <= optimalMaxPmnkSize)
                                        ? headPlusTailLen : optimalMaxPmnkSize; // if small, pmnk == str
    static const std::size_t tailSize = (headPlusTailLen <= optimalMaxPmnkSize)
                                        ? 0 : headPlusTailLen - (optimalMaxPmnkSize);

    struct Head // Movable, references the torso with an index offset from the strAnchor
    {
        int k;
        char pmnk[pmnkSize + 1]; // Poor Man's Normalized Key, see below. Null-terminated.
    };

    /* B-tree Indexes and CPU Caches Goetz Graefe and Per-Ake Larson
        IEEE Proceedings of the 17th International Conference on Data Engineering
        Section 6.1, "Poor Man's Normalized Keys", p. 355:

        This technique works well only if common
        key prefixes are truncated before the poor man's
        normalized keys are extracted. In that case, a small poor
        man's normalized key (e.g., 2 bytes) may be sufficient to
        avoid most cache faults on the full records; if prefix truncation
        is not used, even a fairly large poor man's normalized
        key may not be very effective, in particular in B-tree
        leaves.
    */

    struct Torso // Should be immutable and immobile
    {
        char tail[tailSize + 1]; // Null-terminated.
    };

    struct Unity
    {
        Head h;
        Torso t;
    };

    // Notice, no default assignments above, which yields an empty default constructor, which
    // means release builds (dropping empty functions) will not have quadratic behavior for
    // cross-container element movement (IMHO)

    Unity s;

public:

    class Item_Size_Mismatch : public runtime_error
    {
    public:
        Item_Size_Mismatch() :
            runtime_error("array[0].structSize() must equal arrayByteLength/arrayCount (possible compiler dependency)") {}
    };

    class Assign_String_Too_Long : public runtime_error
    {
    public:
        Assign_String_Too_Long() :
            runtime_error("assign function called with overlong string") {}
    };

    class Bad_Array_Anchor_Or_K_Init : public runtime_error
    {
    public:
        Bad_Array_Anchor_Or_K_Init() :
            runtime_error("after allocating the array, you MUST call array[0].dropAnchorKInit(array, WITH_A_CORRECT_arrayCount)") {}
    };

    class Already_Array_Anchor : public runtime_error
    {
    public:
        Already_Array_Anchor() :
            runtime_error("you must ONLY ONCE call array[0].dropAnchor(arrayByteLength/arrayCount)") {}
    };

    class Should_Not_Execute_Here : public runtime_error
    {
    public:
        Should_Not_Execute_Here() :
            runtime_error("program should not execute here (performance debugging)") {}
    };

    Symbiont()
    {
    }

    Symbiont(const Symbiont& rhs)
    {
        s.h = rhs.s.h; // heads only move
    }

    Symbiont& operator = (const Symbiont& rhs)
    {
        s.h = rhs.s.h; // heads only move
        return *this;
    }

    Symbiont& assign(const char* str)
    {
        int len = strlen(str);
        if (len > headPlusTailLen) throw Assign_String_Too_Long();
        s.h.pmnk[0] = 0;
        s.t.tail[0] = 0;
        if (len > pmnkSize)
        {
            strncpy(s.h.pmnk, str, pmnkSize);
            s.h.pmnk[pmnkSize] = 0;
            strcpy(s.t.tail, str+pmnkSize);
        }
        else
        {
            strcpy(s.h.pmnk, str);
        }
        return *this;
    }

    size_t size() const noexcept
    {
        return headPlusTailLen;
    }

    size_t structSize() const noexcept
    {
        return sizeof(s);
    }

    bool operator < (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return false; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare < 0) return true; // independent of the tail
        else if (pmnkCompare > 0 || (pmnkCompare == 0 && tailSize == 0)) return false; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) < 0);
            return state;
        }
    }

    bool operator <= (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return true; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare < 0 || (pmnkCompare == 0 && tailSize == 0)) return true; // independent of the tail
        else if (pmnkCompare > 0) return false; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) < 1);
            return state;
        }
    }

    bool operator == (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return true; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare == 0 && tailSize == 0) return true; // independent of the tail
        else if (pmnkCompare != 0) return false; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) == 0);
            return state;
        }
    }

    bool operator != (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return false; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare == 0 && tailSize == 0) return false; // independent of the tail
        else if (pmnkCompare != 0) return true; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) != 0);
            return state;
        }
    }

    bool operator >= (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return true; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare > 0 || (pmnkCompare == 0 && tailSize == 0)) return true; // independent of the tail
        else if (pmnkCompare < 0 ) return false; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) > -1);
            return state;
        }
    }

    bool operator > (const Symbiont& rhs)
    {
        if (s.h.k == rhs.s.h.k) return false; // pivot, temp or external array identity optimization
        int pmnkCompare = strcmp(s.h.pmnk, rhs.s.h.pmnk);
        if (pmnkCompare > 0) return true; // independent of the tail
        else if (pmnkCompare < 0 || (pmnkCompare == 0 && tailSize == 0)) return false; // don't check tail
        // the pmnk are identical, need to look at tails
        else
        {
            if (strAnchor == 0 || s.h.k < 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
            // throw Should_Not_Execute_Here(); // performance debugging
            char *lhsStr = strAnchor + (s.h.k * sizeof(s)); // *array[s.h.k].s.t.tail
            char *rhsStr = strAnchor + (rhs.s.h.k * sizeof(s)); // *array[rhs.s.h.k].s.t.tail
            bool state = (strcmp(lhsStr, rhsStr) > 0);
            return state;
        }
    }

    void dropAnchorKInit(Symbiont symbArr[], std::size_t size) // parameters should look like (array, array count)
    {
        // if (strAnchor != 0) throw Already_Array_Anchor();
        if (sizeof(symbArr[0]) != sizeof(s)) throw Item_Size_Mismatch();
	strAnchor = symbArr[0].s.t.tail;
        for (int i = 0; i < size; ++i) symbArr[i].s.h.k = i;
    }

    friend ostream& operator<< (ostream &os, const Symbiont& rhs)
    {
        if (strAnchor == 0 || rhs.s.h.k < 0) throw Bad_Array_Anchor_Or_K_Init();
        os << rhs.s.h.pmnk;
        char *tailStr = strAnchor + (rhs.s.h.k * sizeof(s));
        os << tailStr;
        return os;
    }

    void reserve(int i) { } // no-op


};

#endif // SYMBIONT_H_INCLUDED


