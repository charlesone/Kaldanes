#ifndef DIRECT_H_INCLUDED
#define DIRECT_H_INCLUDED

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

Direct.h - header file for Direct string type, which are variable-length (with an upper bound)
  null-terminated byte strings that have their bytes moved as a single body when they are swapped
  as in sorting, not just moving their pointers (following the Sort Benchmark rules.) These might
  be a candidate for the Indy Sort. Direct has "value-string semantics" as Stroustrup defined for
  his String type (C++11, chapter 19.3) Direct strings are the fastest for short strings: linear
  for quick sort AND merge sort (as opposed to the type <string> which is slower for quick sort
  and quadratic for merge sort.) However, even for longer strings Direct are sub-linear in time
  complexity for string length due to cache pre-fetch (that means when you double the length of
  the strings being sorted, the time taken is quite a bit less than double.) They are designed
  to be used  with slab allocation/deallocation on the stack, as opposed to fine-grained allocators.
  Since the allocated slab never needs to contain pointers, the slab data structure is base+offset
  and can be mmapped to a file or /dev/shm and shared locally or across  a memory fabric like Gen-Z,
  or stored and transmitted, or mmapped over an NFS: consistency considerations are an issue for
  sharing, of course (caveat participem).
*/

#include <iostream>

using namespace std;

// My intent is for this to work for more than just typename char someday: wchar_t, char16_t, char32_t
template <typename T, std::size_t maxStringSize>
class Direct
{
protected:

    static const std::size_t length = maxStringSize;

    struct Struct
    {
        T arr[length + 1]; // null termination
    };

    // Notice, no default assignments above, which yields an empty default constructor, which
    // means release builds (dropping empty functions) will not have quadratic behavior for
    // cross-container element movement (IMHO)

    Struct r;

public:

    class Assign_String_Too_Long : public runtime_error
    {
    public:
        Assign_String_Too_Long() :
            runtime_error("assign function called with overlong string") {}
    };

    class Item_Size_Mismatch : public runtime_error
    {
    public:
        Item_Size_Mismatch() :
            runtime_error("array[0].structSize() must equal array items/arraySize (possible compiler dependency)") {}
    };

    size_t size() const noexcept
    {
        return length;
    }

    size_t structSize() const noexcept
    {
        return sizeof(r);
    }

    void checkUnitLength(std::size_t size) // parameter size should be (array length/array count)
    {
        if (sizeof(r) != size) throw Item_Size_Mismatch();
    }

    Direct& assign (const char* str)
    {
        int strLength = strlen(str);
        if (strLength > length) throw Assign_String_Too_Long();
        strcpy(r.arr, str);
        return *this;
    }

    bool operator < (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) < 0);
    }

    bool operator <= (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) < 1);
    }

    bool operator == (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) == 0);
    }

    bool operator != (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) != 0);
    }

    bool operator >= (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) > -1);
    }

    bool operator > (const Direct& rhs)
    {
        return (strcmp(r.arr, rhs.r.arr) > 0);
    }

    friend ostream& operator<< (ostream &os, const Direct& right)
    {
        os << right.r.arr;
        return os;
    }

    void reserve(int i) { } // no-op
};

#endif // DIRECT_H_INCLUDED
