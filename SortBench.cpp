
// Various sorts of various sizes and types (and lengths) measured with precision for comparison
// Controls should be obvious in the main and the four #defines just below the #includes

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

  SortBench program results: comparing the Direct, Head, Symbiont and std::string
  classes.

  Caveat: these are single-threaded sorting comparisons. Multi-threading,
  distribution, and best sorting algorithm are a separate exercise. Having the
  fastest strings on the fastest containers makes for the fastest single threaded
  sorting, independent of the algorithm, distribution and the parallelization. Slow
  components are not worthy of fast algorithms and excellent distributed
  parallelization.

  SortBench is a program in the Kaldanes GitHub code base:
  https://github.com/charlesone/Kaldanes

  All files concerned are located in there and can be built by the “make all”
  command (including the header files Direct.h, Symbiont.h, Head.h, and Sorts.h).

  SortBench is a C++11 Linux console program churning out performance output
  statistics line-by-line to the console. It does performance analysis using the
  precision nanosecond clock support from C++11 on Linux. SortBench has not yet
  been run on Windows.

  Four types of 8-byte strings are tested against the same template quick sort
  functions, and next plot, merge sort: (1) std::string class objects are provided
  by C++ libraries and have the ability to be shared with copy-on-write support for
  threading, so moving them is by pointer, (2) Direct template class strings, which
  move as a single element during sorting, (3) Symbiont template class strings,
  which are stored in a block with a head and a body, such that during sorting the
  heads move and the bodies stay in place, and (4) Head template class strings
  which have their heads stored in a separate array, and which declare a Direct
  array internally to store the bodies which don’t move.

  A generically interesting thing is how random strings are generated for the
  SortBench program. The number of calls to the random bits generation is reduced
  by an average of four across different string lengths. This was done by
  generating them 64 bits wide at a time into a char overlay. No comparisons were
  done, but it is mighty fast.

*/

// Remember to set the C++11 switch in the IDE or compiler!
// Remember to use release builds if you are analyzing performance, otherwise very slow!
// Remember to set the "ulimit -s" soft and hard stack limits to unlimited
//    permanently, otherwise these tests won't get very far!
//

#define __STDC_WANT_LIB_EXT1__ 1
#include <locale>
//#include <codecvt> // this is needed for u16string and u32string to work as PString: not yet there
#include <iostream>
#include <sstream>
#include <string>
#include <climits>
#include <exception>
#include <typeinfo>
#include <functional>
#include <stdexcept>
#include <ctime>
#include <cstdlib>
#include <random>
#include <chrono>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iterator>
#include "Direct.h"
#include "Symbiont.h"
#include "Head.h"

static const bool debugTrace = false;

#include "Sorts.h"

#ifdef __GNUG__
#include <cxxabi.h> // gcc only: fetching type names
#endif // __GNUG__

// Controls for displaying input and output, checking if sorted, prompting in between sets
// (so that you can eyeball the input randoms and output sorted,) and finally, printing the  data
// in semicolon separated format (SSV, not CSV, because commas and colons occur in typenames,) there
// are also units in the format, but they are easily bulk edited out.

//#define printInput
//#define printSorted
//#define checkSorted // statistics displays are influenced, therefore those displays are blocked
//#define justPrompt
#define semicolonSeparated // printing the disrupting input and sorted displays is blocked

using namespace std;
using namespace std::chrono;

// power of two: it doubles for every set of iterations until max or out of memory
int initialArraySize;
int arraySize;
int initialArrayMax;
int arrayMax;
// largest negative 32 bit integer prime number
static const int inviolate32 = -2147483647L;
// largest negative 64 bit integer prime number
const long long int inviolate64 = -9223372036854775783LL;

// this iterates to average the statistics for every dataset
// more iterations means smoother plotted curves (especially for
// the short runs, the long runs tend to converge on their own)
int initialIterations;
int iterations;
int charStringLength = 32;
string sortType;
enum Genus {numbers, strings};
Genus genus;

// Statistics
duration<double, nano> testTimes;
duration<double, nano> randomGenerationTimes;
duration<double, nano> totalTimes;
duration<double, nano> overheadTimes;

class SortBench
{
public:

    void display(wstring arr[], int size) // for wstrings
    {
        for (int i = 0; i < size; ++i)
        {
            wcout << arr[i] << " ";
        }
        cout << endl << endl;
    }
    template<typename T>
    void display(T arr[], int size) // for everything else
    {
        cout.precision(1);
        for (int i = 0; i < size; ++i)
        {
            cout << arr[i] << " ";
        }
        cout << endl << endl;
    }

    /* Work in progress

    template<typename T>
    string displayTypeName()
    {
        typedef typename std::remove_reference<T>::type TR;
        string typeName = typeid(TR).name();

    #ifdef __GNUG__
        int status = 0;
        char *readableName = abi::__cxa_demangle(typeName.c_str(), NULL, NULL, &status);
        if (status == 0)
        {
            typeName = readableName;
            std::free(readableName);
        }
    #endif // __GNUG__

        if (std::is_const<TR>::value) typeName += " const";
        if (std::is_volatile<TR>::value) typeName += " volatile";
        if (std::is_lvalue_reference<T>::value) typeName += " &";
        else if (std::is_rvalue_reference<T>::value) typeName += " &&";
        typeName += " ";
        return typeName;
    }

    template<typename T>
    string displayArrayTypeName(T arr[])
    {
        stringstream stm;
        stm << "Array of " << arraySize << " of type: " << displayTypeName<T>();
        return stm.str();
    }

    End of work in progress */

    template<typename T>
    void displayArrayTypeName(T arr[])
    {
        string typeName = typeid(T).name();

#ifdef __GNUG__
        int status = 0;
        char *readableName = abi::__cxa_demangle(typeName.c_str(), NULL, NULL, &status);
        if (status == 0)
        {
            typeName = readableName;
            std::free(readableName);
        }
#endif // __GNUG__

#ifdef semicolonSeparated
        cout << endl << sortType <<"; " <<  typeName << " type; ";
#else // if not semicolonSeparated
        cout << endl << sortType <<" of array of " << arraySize << " of type: " <<  typeName;
#endif // if not semicolonSeparated
    }

    template<std::size_t size>
    class pageTableAllocator
    {
    public:
        char arr[size];
    };

    void initializeVars(int initArraySize = 16, int initArrayMax = 10000, int initIterations = 1)
    {

        initialArraySize = initArraySize;
        initialArrayMax = initArrayMax; // going to allocate page table this big, make it the actual size you want
        initialIterations = initIterations;
        const int initialElemSize = 1024;
        // Now, we allocate a large array to set up (grab) the page table entries, or the first
        // test to breach new ground in memory size will get bad measurements. Since the array
        // is on the stack and an automatic variable, it will disappear after this procedure
        // returns, but the page table entries will remain for the lifetime of this process.
        cout << endl <<
             "Trying to allocate PTEs to accomodate 2 * " << initArrayMax << " * " << initialElemSize << " bytes, may take time ..."
             << endl;
        pageTableAllocator<initialElemSize> elems[2 * initArrayMax];
        strcpy(elems[initArrayMax - 10].arr, "Page Table allocation completed.");
        //elems[0].r.arr = "Page Table allocation completed.";
        cout << elems[initArrayMax - 10].arr << endl;
    }

    void resetVars()
    {
        arraySize = initialArraySize;
        arrayMax = initialArrayMax;
        iterations = initialIterations;
    }

    void resetStats()
    {
        // genus is set in the testLopp() function of each class before displayStats is called.
        swaps = 0;
        compares = 0;
        testTimes = duration<double, nano> (0);
        randomGenerationTimes = duration<double, nano> (0);
        totalTimes = duration<double, nano> (0);
        overheadTimes = duration<double, nano> (0);
    }

    class Enum_Genus_Not_Initialized : public runtime_error
    {
    public:
        Enum_Genus_Not_Initialized() :
            runtime_error("The enum named genus must be initialized prior to access") {}
    };

    void displayStats()
    {
        overheadTimes = totalTimes - randomGenerationTimes - testTimes;
        string genusName;
        if (genus == numbers) genusName = "numbers";
        else if (genus == strings) genusName = "strings";
        else throw Enum_Genus_Not_Initialized();
#ifdef checkSorted
        cout << "Statistics are not displayed when array checking is selected." << endl;
#endif
#if defined (semicolonSeparated) && ! defined (checkSorted)
        cout.precision(3);
        cout << arraySize << " " << genusName << " array" << "; ";
        cout << fixed << chrono::duration <double, micro> (testTimes / (double) iterations).count() << " sort us (microseconds); ";
        cout << chrono::duration <double, micro> (randomGenerationTimes / (double) iterations).count() << " rand gen us; ";
        cout << chrono::duration <double, micro> (overheadTimes / (double) iterations).count() << " overhead us; ";
        cout << chrono::duration <double, micro> (totalTimes / (double) iterations).count() << " total us; ";
        cout << (double) swaps/ (double) iterations << " swaps; ";
        cout << (double) compares/ (double) iterations << " compares";
#endif // if defined (semicolonSeparated) && ! defined (checkSorted)
#if ! defined (semicolonSeparated) && ! defined (checkSorted)
        cout.precision(3);
        cout << "Average swaps, per sort: " << fixed << (double) swaps/ (double) iterations << endl;
        cout << "Average compares, per sort: " << fixed << (double) compares/ (double) iterations << endl;
        cout << "Average microseconds for generating "
             << arraySize << " random " << genusName << ", per sort: " << endl
             << chrono::duration <double, micro> (randomGenerationTimes / (double) iterations).count() << endl;
        cout << "Average microseconds just sorting "
             << arraySize << " " << genusName << ", per sort: " << endl
             << chrono::duration <double, micro> (testTimes / (double) iterations).count() << endl;
        cout << "Average total microseconds (+overhead) for sorting "
             << arraySize << " " << genusName << ", per sort: " << endl
             << chrono::duration <double, micro> (totalTimes / (double) iterations).count() << endl;
        cout << "Average microseconds of overhead for sorting "
             << arraySize << " " << genusName << ", per sort: " << endl
             << chrono::duration <double, micro> (overheadTimes / (double) iterations).count() << endl;
        cout << "____________________________________________________________" << endl;
#endif // if ! defined (semicolonSeparated) && ! defined (checkSorted)
    }

    class Random_String_Too_Long : public runtime_error
    {
    public:
        Random_String_Too_Long() :
            runtime_error("Random strings requested are too long exception") {}
    };

    class Random_String_Too_Short : public runtime_error
    {
    public:
        Random_String_Too_Short() :
            runtime_error("Random strings requested are too short exception") {}
    };

    void checkStringLength(int length)
    {
        if (length < 2) throw Random_String_Too_Short();
        if (length > 1024) throw Random_String_Too_Long();
        return;
    }

    // Only calls distribution(generator) on the average, one time for every four characters.
    // Should be faster than calling it on every character, I think
    template<typename T>
    void generateRandomStrings(T items[], int sizeArray, int sizeString)
    {
        char radixString[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        const int radixLen = sizeof(radixString) - 1; // it's null-terminated
        unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
        std::default_random_engine generator(seed);
        std::uniform_int_distribution<unsigned long long>
        distribution(numeric_limits<unsigned long long>::min(), numeric_limits<unsigned long long>::max());
        int uint64Length = sizeString/8 + 1; // rounding up to having more than enough random bits
        if (sizeString%8 == 0) --uint64Length; // rounding back the even cases to just enough bits
        union byteRand
        {
            uint64_t uint64Rand[128];
            uint8_t  uint8Rand[1024];
            char     charRand[1025];
        };
        byteRand overlay;

        for (int i = 0; i < sizeArray; ++i)
        {
            for (int j = 0; j < uint64Length; ++j)
            {
                overlay.uint64Rand[j] = distribution(generator);
            }
            for (int j = 0; j < sizeString; ++j)
            {
                overlay.uint8Rand[j] = radixString[overlay.uint8Rand[j] % radixLen];
            }
            overlay.charRand[sizeString] = 0;
            items[i].reserve(sizeString);
            items[i].assign(overlay.charRand);
        }
    }

}; // end of SortBench

class Array_Not_Sorted : public runtime_error
{
public:
    Array_Not_Sorted() :
        runtime_error("Array items are not in sorted order") {}
};

template<typename T>
void throwExceptionIfUnsorted(T arr[], int size)
{
    for (int i = 1; i < size - 1; ++i)
    {
        if (arr[i - 1] > arr[i])
        {
            throw Array_Not_Sorted();
        }
    }
}

class Not_Working_Yet : public runtime_error
{
public:
    Not_Working_Yet() :
        runtime_error("This part not working yet") {}
};

// measure scale up against a Numeric type (like a short, long or double),
template<typename T>
class Numeric: public SortBench
{
public:

    std::function<void(T[], int)> sortFunction; // this is the prototype for all sort functions

    // minimum value for random number generation for numeric types
    T tMin;
    // maximum value for random number generation for numeric types
    T tMax;

    // numeric types need min and max and numeric random values
    void test(T items[])
    {
        high_resolution_clock::time_point startRandomStringGeneration = high_resolution_clock::now();
        /* can't use this method for floating types
        unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
        std::default_random_engine generator(seed);
        std::uniform_int_distribution<T> distribution(tMin, tMax);
        */
        srand(unsigned(time(0)));

        for (int i = 0; i < arraySize; ++i)
        {
            //items[i] = distribution(generator);
            items[i] = (rand() % (int(tMax - tMin - 1))) + (tMin);
        }
        randomGenerationTimes += duration_cast<duration<double>> (high_resolution_clock::now() - startRandomStringGeneration);

#if defined (printInput) && ! defined (semicolonSeparated)
        cout << "Input: ";
        display(items, arraySize);
#endif

        high_resolution_clock::time_point start = high_resolution_clock::now();
        sortFunction(items, arraySize);
        testTimes += duration_cast<duration<double>> (high_resolution_clock::now() - start);

#if defined (printSorted) && ! defined (semicolonSeparated)
        cout << "Sorted: ";
        display(items, arraySize);
#endif

        return;
    }

    void testloop(T min, T max)
    {
        tMin = min;
        tMax = max;
        genus = numbers;
        resetStats();
        high_resolution_clock::time_point start = high_resolution_clock::now();
        for (int i = 0; i < iterations; ++i)
        {
            T items[arraySize];
            if (i == 0) // only display type information before first iteration
            {
                displayArrayTypeName(items);
#ifdef semicolonSeparated
                cout << iterations << " iteration; ";
#else // if not semicolonSeparated
                cout << endl;
                cout << iterations << " iteration";
                if (iterations > 1) cout << "s";
                cout << endl;
#endif // if not semicolonSeparated
            }
            test(items);
#ifdef checkSorted
            throwExceptionIfUnsorted(items, arraySize);
#endif
        }
        totalTimes = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        displayStats();
#ifdef justPrompt
        string s;
        getline(cin, s);
#endif
        return;
    }

    void driver(T min, T max)
    {
        resetVars();
        while (arraySize <= arrayMax)
        {
            testloop(min, max);
            arraySize <<= 1; // double the array size for the next dataset
        }
        return;
    }

    void selectionSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        sortType = "Selection Sort";
        sortFunction = selectionSortInvoke<T>;
        driver(min, max);
    }

    void shellSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        sortType = "Shell Sort";
        sortFunction = shellSortInvoke<T>;
        driver(min, max);
    }

    void insertionSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        sortType = "Insertion Sort";
        sortFunction = insertionSortInvoke<T>;
        driver(min, max);
    }

    void mergeSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        sortType = "Merge Sort";
        sortFunction = mergeSortInvoke<T>;
        driver(min, max);
    }

    void quickSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        sortType = "Quick Sort";
        sortFunction = quickSortInvoke<T>;
        driver(min, max);
    }

    void stlSort(T min = numeric_limits<T>::min(), T max = numeric_limits<T>::max())
    {
        throw Not_Working_Yet();
        sortType = "STL Sort";
        sortFunction = stlSortInvoke<T>;
        driver(min, max);
    }

};

// measure scale up against a PString (basic_string) type (like a string or wstring)
template<typename T>
class PString: public SortBench
{
public:

    std::function<void(T[], int)> sortFunction; // this is the prototype for all sort functions

    // comparable types need (like string) need random string generation, Tmax and Tmin ignored
    void test(T items[], int stringLength)
    {
        high_resolution_clock::time_point startRandomStringGeneration = high_resolution_clock::now();
        generateRandomStrings(items, arraySize, stringLength);
        randomGenerationTimes += duration_cast<duration<double>> (high_resolution_clock::now() - startRandomStringGeneration);

#if defined (printInput) && ! defined (semicolonSeparated)
        cout << "Input: ";
        display(items, arraySize);
#endif

        high_resolution_clock::time_point start = high_resolution_clock::now();
        sortFunction(items, arraySize);
        testTimes += duration_cast<duration<double>> (high_resolution_clock::now() - start);

#if defined (printSorted) && ! defined (semicolonSeparated)
        cout << "Sorted: ";
        display(items, arraySize);
#endif

        return;
    }

    void testloop(int initialStringLength, int maxStringDoublingLength)
    {
        checkStringLength(initialStringLength);
        checkStringLength(maxStringDoublingLength);
        int stringLength = initialStringLength;
        while (stringLength <= maxStringDoublingLength)
        {
            genus = strings;
            resetStats();
            high_resolution_clock::time_point start = high_resolution_clock::now();
            for (int i = 0; i < iterations; ++i)
            {
                T items[arraySize];
                if (i == 0) // only display type information before first iteration
                {
                    displayArrayTypeName(items);
#ifdef semicolonSeparated
                    cout << stringLength << " byte length; " << iterations << " iteration; ";
#else // if not semicolonSeparated
                    cout << " of length: " << stringLength << endl;
                    cout << iterations << " iteration";
                    if (iterations > 1) cout << "s";
                    cout << endl;
#endif // if not semicolonSeparated
                }
                test(items, stringLength);
#ifdef checkSorted
                throwExceptionIfUnsorted(items, arraySize);
#endif
            }
            totalTimes = duration_cast<duration<double>> (high_resolution_clock::now() - start);
            displayStats();
#ifdef justPrompt
            string s;
            getline(cin, s);
#endif
            stringLength <<= 1;
        }
        return;
    }

    void driver(int initialStringLength, int maxStringDoublingLength)
    {
        resetVars();
        while (arraySize <= arrayMax)
        {
            testloop(initialStringLength, maxStringDoublingLength);
            arraySize <<= 1; // double the array size for the next dataset
        }
        return;
    }

    void selectionSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        sortType = "Selection Sort";
        sortFunction = selectionSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

    void shellSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        sortType = "Shell Sort";
        sortFunction = shellSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

    void insertionSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        sortType = "Insertion Sort";
        sortFunction = insertionSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

    void mergeSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        sortType = "Merge Sort";
        sortFunction = mergeSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

    void quickSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        sortType = "Quick Sort";
        sortFunction = quickSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

    void stlSort(int initialStringLength = 32, int maxStringDoublingLength = 32)
    {
        throw Not_Working_Yet();
        sortType = "STL Sort";
        sortFunction = stlSortInvoke<T>;
        driver(initialStringLength, maxStringDoublingLength);
    }

};

// Measure scale up against a Direct, which are variable-length (with an upper bound) null-terminated
// byte strings that have their bytes moved as a single body when they are swapped, not just moving
// their pointers (following the Sort Benchmark rules.) These might be a candidate for the Indy Sort.
// Direct has "value-string semantics" as Stroustrup defined for his String type (C++11, chapter 19.3)
// Direct strings are the fastest for short strings: linear for quick sort AND merge sort (as opposed to
// the type <string> which is slower for quick sort and quadratic for merge sort.
// However, even for longer strings Direct are sub-linear in time complexity for string length due to
// cache pre-fetch (that means when you double the length of the strings being sorted, the time taken
// is quite a bit less than double.) They are designed to be used  with with slab allocation/deallocation
// on the stack, as opposed to fine-grained allocators. Since the allocated slab never needs to contain
// contain pointers, only array indices, the slab data structure is base+offset and can be mmapped to
// a file or /dev/shm and shared locally or across  a memory fabric like Gen-Z, or stored and transmitted,
// or mmapped over an NFS: consistency considerations are an issue for sharing, of course (caveat participem).
template <typename T>
class DString: public SortBench
{

private:
    // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
    typedef Direct<T, 2> d2;
    typedef Direct<T, 4> d4;
    typedef Direct<T, 8> d8;
    typedef Direct<T, 16> d16;
    typedef Direct<T, 32> d32;
    typedef Direct<T, 64> d64;
    typedef Direct<T, 128> d128;
    typedef Direct<T, 256> d256;
    typedef Direct<T, 512> d512;
    typedef Direct<T, 1024> d1024Max;
    std::function<void(d2[], int)> f2;
    std::function<void(d4[], int)> f4;
    std::function<void(d8[], int)> f8;
    std::function<void(d16[], int)> f16;
    std::function<void(d32[], int)> f32;
    std::function<void(d64[], int)> f64;
    std::function<void(d128[], int)> f128;
    std::function<void(d256[], int)> f256;
    std::function<void(d512[], int)> f512;
    std::function<void(d1024Max[], int)> f1024Max;

public:

    template<typename U>
    void test(U items[], int stringLength, std::function<void(U[], int)> sortFunction)
    {
        high_resolution_clock::time_point startRandomStringGeneration = high_resolution_clock::now();
        generateRandomStrings(items, arraySize, stringLength);
        randomGenerationTimes += duration_cast<duration<double>> (high_resolution_clock::now() - startRandomStringGeneration);

#if defined (printInput) && ! defined (semicolonSeparated)
        cout << "Input: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
        }
        cout << endl << endl;
#endif
        high_resolution_clock::time_point start = high_resolution_clock::now();
        sortFunction(items, arraySize);
        testTimes += duration_cast<duration<double>> (high_resolution_clock::now() - start);

#if defined (printSorted) && ! defined (semicolonSeparated)
        cout << "Sorted: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
        }
        cout << endl << endl;
#endif

        return;
    }

    template<typename U>
    void testloop(std::function<void(U[], int)> sortFunction)
    {
        genus = strings;
        resetStats();
        high_resolution_clock::time_point start = high_resolution_clock::now();
        for (int i = 0; i < iterations; ++i)
        {
            U items[arraySize];
            items[0].checkUnitLength(sizeof(items)/arraySize);
            checkStringLength(items[0].size());
            if (i == 0) // only display type information before first iteration
            {
                displayArrayTypeName(items);
#ifdef semicolonSeparated
                cout << items[0].size() << " byte length; " << iterations << " iteration; ";
#else // if not semicolonSeparated
                cout << endl;
                cout << iterations << " iteration";
                if (iterations > 1) cout << "s";
                cout << endl;
#endif // if not semicolonSeparated
            }
            test(items, items[0].size(), sortFunction);
#ifdef checkSorted
            throwExceptionIfUnsorted(items, arraySize);
#endif
        }
        totalTimes = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        displayStats();
#ifdef justPrompt
        string s;
        getline(cin, s);
#endif
        return;
    }

    void driver()
    {
        resetVars();
        while (arraySize <= arrayMax)
        {
            testloop<d2>(f2);
            testloop<d4>(f4);
            testloop<d8>(f8);
            testloop<d16>(f16);
            testloop<d32>(f32);
            testloop<d64>(f64);
            testloop<d128>(f128);
            testloop<d256>(f256);
            testloop<d512>(f512);
            testloop<d1024Max>(f1024Max);
            arraySize <<= 1; // double the array size for the next dataset
        }
        return;
    }

    void selectionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Selection Sort";
        f2 = selectionSortInvoke<d2>;
        f4 = selectionSortInvoke<d4>;
        f8 = selectionSortInvoke<d8>;
        f16 = selectionSortInvoke<d16>;
        f32 = selectionSortInvoke<d32>;
        f64 = selectionSortInvoke<d64>;
        f128 = selectionSortInvoke<d128>;
        f256 = selectionSortInvoke<d256>;
        f512 = selectionSortInvoke<d512>;
        f1024Max = selectionSortInvoke<d1024Max>;
        driver();
    }

    void shellSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Shell Sort";
        f2 = shellSortInvoke<d2>;
        f4 = shellSortInvoke<d4>;
        f8 = shellSortInvoke<d8>;
        f16 = shellSortInvoke<d16>;
        f32 = shellSortInvoke<d32>;
        f64 = shellSortInvoke<d64>;
        f128 = shellSortInvoke<d128>;
        f256 = shellSortInvoke<d256>;
        f512 = shellSortInvoke<d512>;
        f1024Max = shellSortInvoke<d1024Max>;
        driver();
    }

    void insertionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Insertion Sort";
        f2 = insertionSortInvoke<d2>;
        f4 = insertionSortInvoke<d4>;
        f8 = insertionSortInvoke<d8>;
        f16 = insertionSortInvoke<d16>;
        f32 = insertionSortInvoke<d32>;
        f64 = insertionSortInvoke<d64>;
        f128 = insertionSortInvoke<d128>;
        f256 = insertionSortInvoke<d256>;
        f512 = insertionSortInvoke<d512>;
        f1024Max = insertionSortInvoke<d1024Max>;
        driver();
    }

    void mergeSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Merge Sort";
        f2 = mergeSortInvoke<d2>;
        f4 = mergeSortInvoke<d4>;
        f8 = mergeSortInvoke<d8>;
        f16 = mergeSortInvoke<d16>;
        f32 = mergeSortInvoke<d32>;
        f64 = mergeSortInvoke<d64>;
        f128 = mergeSortInvoke<d128>;
        f256 = mergeSortInvoke<d256>;
        f512 = mergeSortInvoke<d512>;
        f1024Max = mergeSortInvoke<d1024Max>;
        driver();
    }

    void quickSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Quick Sort";
        f2 = quickSortInvoke<d2>;
        f4 = quickSortInvoke<d4>;
        f8 = quickSortInvoke<d8>;
        f16 = quickSortInvoke<d16>;
        f32 = quickSortInvoke<d32>;
        f64 = quickSortInvoke<d64>;
        f128 = quickSortInvoke<d128>;
        f256 = quickSortInvoke<d256>;
        f512 = quickSortInvoke<d512>;
        f1024Max = quickSortInvoke<d1024Max>;
        driver();
    }

    void stlSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        throw Not_Working_Yet();
        sortType = "STL Sort";
        f2 = stlSortInvoke<d2>;
        f4 = stlSortInvoke<d4>;
        f8 = stlSortInvoke<d8>;
        f16 = stlSortInvoke<d16>;
        f32 = stlSortInvoke<d32>;
        f64 = stlSortInvoke<d64>;
        f128 = stlSortInvoke<d128>;
        f256 = stlSortInvoke<d256>;
        f512 = stlSortInvoke<d512>;
        f1024Max = stlSortInvoke<d1024Max>;
        driver();
    }

};

// Measure scale up against a Hybrid Symbiont string, which are variable-length (with an upper bound)
// null-terminated byte strings that have their indexes and a "poor man's normalized key" (pmnk) moved
// when they are swapped, without moving their tail strings (ignoring the Sort Benchmark rules).
// Symbiont has "value-string semantics" as Stroustrup defined for his String type (C++11, chapter 19.3)
// These might be a candidate for the Indy Sort. Symbiont strings behave like Direct (DString) strings
// for short lengths (32 bytes or less, by internally equating the pmnk length with the string length.)
// This allows Symbiont strings to almost match Direct strings in performance for short strings and
// still have constant time complexity for string length: they are a candidate for general purpose
// string programming with stack slab allocation/deallocation as opposed to the fine-grained allocators,
// which are necessary for pointer strings like <string>. Symbiont strings are quadratic in the debug build
// and linear in the release build for both quick sort and merge sort, so remember to use the release build
// for performance analysis. They are designed to be used  with with slab allocation/deallocation on the
// stack, as opposed to fine-grained allocators. Since the allocated slab never needs to contain pointers,
// only array indices, the slab data structure is base+offset and can be mmapped to a file or /dev/shm and
// shared locally or across a memory fabric such as Gen-Z, or stored and transmitted, or mmapped over
// an NFS: consistency considerations are an issue for sharing, of course (caveat participem).
class Hybrid: public SortBench
{

private:
    // can't increase lengths on these dynamically, requires separate types and expansions (sigh)

    typedef Symbiont<2> s2;
    typedef Symbiont<4> s4;
    typedef Symbiont<8> s8;
    typedef Symbiont<16> s16;
    typedef Symbiont<32> s32;
    typedef Symbiont<64> s64;
    typedef Symbiont<128> s128;
    typedef Symbiont<256> s256;
    typedef Symbiont<512> s512;
    typedef Symbiont<1024> s1024Max;
    std::function<void(s2[], int)> f2;
    std::function<void(s4[], int)> f4;
    std::function<void(s8[], int)> f8;
    std::function<void(s16[], int)> f16;
    std::function<void(s32[], int)> f32;
    std::function<void(s64[], int)> f64;
    std::function<void(s128[], int)> f128;
    std::function<void(s256[], int)> f256;
    std::function<void(s512[], int)> f512;
    std::function<void(s1024Max[], int)> f1024Max;

public:

    template<typename U>
    void test(U items[], int stringLength, std::function<void(U[], int)> sortFunction)
    {
        high_resolution_clock::time_point startRandomStringGeneration = high_resolution_clock::now();
        generateRandomStrings(items, arraySize, stringLength);
        randomGenerationTimes += duration_cast<duration<double>> (high_resolution_clock::now() - startRandomStringGeneration);

#if defined (printInput) && ! defined (semicolonSeparated)
        cout << "Input: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
            // before sorting, no k-values have moved, so the symbiont's head and tail are aligned
        }
        cout << endl << endl;
#endif
        high_resolution_clock::time_point start = high_resolution_clock::now();
        sortFunction(items, arraySize);
        testTimes += duration_cast<duration<double>> (high_resolution_clock::now() - start);

#if defined (printSorted) && ! defined (semicolonSeparated)
        cout << "Sorted: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
            // after sorting, all of the k-values have moved away from their tail strings (if tails nonempty)
        }
        cout << endl << endl;
#endif

        return;
    }

    template<typename U>
    void testloop(std::function<void(U[], int)> sortFunction)
    {
        genus = strings;
        resetStats();
        high_resolution_clock::time_point start = high_resolution_clock::now();
        for (int i = 0; i < iterations; ++i)
        {
            U items[arraySize];
            items[0].dropAnchorKInit(items, arraySize);
            checkStringLength(items[0].size());
            if (i == 0) // only display type information before first iteration
            {
                displayArrayTypeName(items);
#ifdef semicolonSeparated
                cout << items[0].size() << " byte length; " << iterations << " iteration; ";
#else // if not semicolonSeparated
                cout << endl;
                cout << iterations << " iteration";
                if (iterations > 1) cout << "s";
                cout << endl;
#endif // if not semicolonSeparated
            }
            test(items, items[0].size(), sortFunction);
#ifdef checkSorted
            throwExceptionIfUnsorted(items, arraySize);
#endif
        }
        totalTimes = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        displayStats();
#ifdef justPrompt
        string s;
        getline(cin, s);
#endif
        return;
    }

    void driver()
    {
        resetVars();
        while (arraySize <= arrayMax)
        {
            testloop<s2>(f2);
            testloop<s4>(f4);
            testloop<s8>(f8);
            testloop<s16>(f16);
            testloop<s32>(f32);
            testloop<s64>(f64);
            testloop<s128>(f128);
            testloop<s256>(f256);
            testloop<s512>(f512);
            testloop<s1024Max>(f1024Max);
            arraySize <<= 1; // double the array size for the next dataset
        }
        return;
    }

    void selectionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Selection Sort";
        f2 = selectionSortInvoke<s2>;
        f4 = selectionSortInvoke<s4>;
        f8 = selectionSortInvoke<s8>;
        f16 = selectionSortInvoke<s16>;
        f32 = selectionSortInvoke<s32>;
        f64 = selectionSortInvoke<s64>;
        f128 = selectionSortInvoke<s128>;
        f256 = selectionSortInvoke<s256>;
        f512 = selectionSortInvoke<s512>;
        f1024Max = selectionSortInvoke<s1024Max>;
        driver();
    }

    void shellSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Shell Sort";
        f2 = shellSortInvoke<s2>;
        f4 = shellSortInvoke<s4>;
        f8 = shellSortInvoke<s8>;
        f16 = shellSortInvoke<s16>;
        f32 = shellSortInvoke<s32>;
        f64 = shellSortInvoke<s64>;
        f128 = shellSortInvoke<s128>;
        f256 = shellSortInvoke<s256>;
        f512 = shellSortInvoke<s512>;
        f1024Max = shellSortInvoke<s1024Max>;
        driver();
    }

    void insertionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Insertion Sort";
        f2 = insertionSortInvoke<s2>;
        f4 = insertionSortInvoke<s4>;
        f8 = insertionSortInvoke<s8>;
        f16 = insertionSortInvoke<s16>;
        f32 = insertionSortInvoke<s32>;
        f64 = insertionSortInvoke<s64>;
        f128 = insertionSortInvoke<s128>;
        f256 = insertionSortInvoke<s256>;
        f512 = insertionSortInvoke<s512>;
        f1024Max = insertionSortInvoke<s1024Max>;
        driver();
    }

    void mergeSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Merge Sort";
        f2 = mergeSortInvoke<s2>;
        f4 = mergeSortInvoke<s4>;
        f8 = mergeSortInvoke<s8>;
        f16 = mergeSortInvoke<s16>;
        f32 = mergeSortInvoke<s32>;
        f64 = mergeSortInvoke<s64>;
        f128 = mergeSortInvoke<s128>;
        f256 = mergeSortInvoke<s256>;
        f512 = mergeSortInvoke<s512>;
        f1024Max = mergeSortInvoke<s1024Max>;
        driver();
    }

    void quickSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Quick Sort";
        f2 = quickSortInvoke<s2>;
        f4 = quickSortInvoke<s4>;
        f8 = quickSortInvoke<s8>;
        f16 = quickSortInvoke<s16>;
        f32 = quickSortInvoke<s32>;
        f64 = quickSortInvoke<s64>;
        f128 = quickSortInvoke<s128>;
        f256 = quickSortInvoke<s256>;
        f512 = quickSortInvoke<s512>;
        f1024Max = quickSortInvoke<s1024Max>;
        driver();
    }

    void stlSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        throw Not_Working_Yet();
        sortType = "STL Sort";
        f2 = stlSortInvoke<s2>;
        f4 = stlSortInvoke<s4>;
        f8 = stlSortInvoke<s8>;
        f16 = stlSortInvoke<s16>;
        f32 = stlSortInvoke<s32>;
        f64 = stlSortInvoke<s64>;
        f128 = stlSortInvoke<s128>;
        f256 = stlSortInvoke<s256>;
        f512 = stlSortInvoke<s512>;
        f1024Max = stlSortInvoke<s1024Max>;
        driver();
    }
};

// Measure scale up against Isolate Head and tail strings, which are variable-length (with an upper
// bound) null-terminated byte strings that have their indexes and a "poor man's normalized key" (pmnk)
// moved when they are swapped, without moving their tail strings (ignoring the Sort Benchmark rules).
// Head has "value-string semantics" as Stroustrup defined for his String type (C++11, chapter 19.3)
// These might be a candidate for the Indy Sort. Head strings behave like Direct (DString) strings
// for short lengths (32 bytes or less, by internally equating the pmnk length with the string length.)
// This allows Head strings to almost match Direct strings in performance for short strings and
// still have constant time complexity for string length: they are a candidate for general purpose
// string programming with stack slab allocation/deallocation as opposed to the fine-grained allocators,
// which are necessary for pointer strings like <string>. Head strings are quadratic in the debug build
// and linear in the release build for both quick sort and merge sort, so remember to use the release build
// for performance analysis. They are designed to be used  with with slab allocation/deallocation on the
// stack, as opposed to fine-grained allocators. Since the allocated slab never needs to contain pointers,
// only array indices, the slab data structure is base+offset and can be mmapped to a file or /dev/shm and
// shared locally or across a memory fabric such as Gen-Z, or stored and transmitted, or mmapped over
// an NFS: consistency considerations are an issue for sharing, of course (caveat participem).
class Isolate: public SortBench
{

private:
    // can't increase lengths on these dynamically, requires separate types and expansions (sigh)

    typedef Head<2> h2;
    typedef Head<4> h4;
    typedef Head<8> h8;
    typedef Head<16> h16;
    typedef Head<32> h32;
    typedef Head<64> h64;
    typedef Head<128> h128;
    typedef Head<256> h256;
    typedef Head<512> h512;
    typedef Head<1024> h1024Max;
    std::function<void(h2[], int)> f2;
    std::function<void(h4[], int)> f4;
    std::function<void(h8[], int)> f8;
    std::function<void(h16[], int)> f16;
    std::function<void(h32[], int)> f32;
    std::function<void(h64[], int)> f64;
    std::function<void(h128[], int)> f128;
    std::function<void(h256[], int)> f256;
    std::function<void(h512[], int)> f512;
    std::function<void(h1024Max[], int)> f1024Max;

public:

    template<typename U>
    void test(U items[], int stringLength, std::function<void(U[], int)> sortFunction)
    {
        high_resolution_clock::time_point startRandomStringGeneration = high_resolution_clock::now();
        generateRandomStrings(items, arraySize, stringLength);
        randomGenerationTimes += duration_cast<duration<double>> (high_resolution_clock::now() - startRandomStringGeneration);

#if defined (printInput) && ! defined (semicolonSeparated)
        cout << "Input: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
            // before sorting, no k-values have moved, so the symbiont's head and tail are aligned
        }
        cout << endl << endl;
#endif
        high_resolution_clock::time_point start = high_resolution_clock::now();
        sortFunction(items, arraySize);
        testTimes += duration_cast<duration<double>> (high_resolution_clock::now() - start);

#if defined (printSorted) && ! defined (semicolonSeparated)
        cout << "Sorted: ";
        for (int i = 0; i < arraySize; ++i)
        {
            cout << items[i] << " ";
            // after sorting, all of the k-values have moved away from their tail strings (if tails nonempty)
        }
        cout << endl << endl;
#endif

        return;
    }

    template<typename U, typename V>
    void testloop(std::function<void(U[], int)> sortFunction)
    {
        genus = strings;
        resetStats();
        high_resolution_clock::time_point start = high_resolution_clock::now();
        for (int i = 0; i < iterations; ++i)
        {
            U heads[arraySize];
            V tails[arraySize];
            heads[0].dropAnchorKInit(heads, tails, arraySize);
            checkStringLength(heads[0].size());
            if (i == 0) // only display type information before first iteration
            {
                displayArrayTypeName(heads);
#ifdef semicolonSeparated
                cout << heads[0].size() << " byte length; " << iterations << " iteration; ";
#else // if not semicolonSeparated
                cout << endl;
                cout << iterations << " iteration";
                if (iterations > 1) cout << "s";
                cout << endl;
#endif // if not semicolonSeparated
            }
            test(heads, heads[0].size(), sortFunction);
#ifdef checkSorted
            throwExceptionIfUnsorted(heads, arraySize);
#endif
        }
        totalTimes = duration_cast<duration<double>> (high_resolution_clock::now() - start);
        displayStats();
#ifdef justPrompt
        string s;
        getline(cin, s);
#endif
        return;
    }

    void driver()
    {
        resetVars();
        while (arraySize <= arrayMax)
        {
            testloop<h2, h2::tail>(f2);
            testloop<h4, h4::tail>(f4);
            testloop<h8, h8::tail>(f8);
            testloop<h16, h16::tail>(f16);
            testloop<h32, h32::tail>(f32);
            testloop<h64, h64::tail>(f64);
            testloop<h128, h128::tail>(f128);
            testloop<h256, h256::tail>(f256);
            testloop<h512, h512::tail>(f512);
            testloop<h1024Max, h1024Max::tail>(f1024Max);
            arraySize <<= 1; // double the array size for the next dataset
        }
        return;
    }

    void selectionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Selection Sort";
        f2 = selectionSortInvoke<h2>;
        f4 = selectionSortInvoke<h4>;
        f8 = selectionSortInvoke<h8>;
        f16 = selectionSortInvoke<h16>;
        f32 = selectionSortInvoke<h32>;
        f64 = selectionSortInvoke<h64>;
        f128 = selectionSortInvoke<h128>;
        f256 = selectionSortInvoke<h256>;
        f512 = selectionSortInvoke<h512>;
        f1024Max = selectionSortInvoke<h1024Max>;
        driver();
    }

    void shellSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Shell Sort";
        f2 = shellSortInvoke<h2>;
        f4 = shellSortInvoke<h4>;
        f8 = shellSortInvoke<h8>;
        f16 = shellSortInvoke<h16>;
        f32 = shellSortInvoke<h32>;
        f64 = shellSortInvoke<h64>;
        f128 = shellSortInvoke<h128>;
        f256 = shellSortInvoke<h256>;
        f512 = shellSortInvoke<h512>;
        f1024Max = shellSortInvoke<h1024Max>;
        driver();
    }

    void insertionSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Insertion Sort";
        f2 = insertionSortInvoke<h2>;
        f4 = insertionSortInvoke<h4>;
        f8 = insertionSortInvoke<h8>;
        f16 = insertionSortInvoke<h16>;
        f32 = insertionSortInvoke<h32>;
        f64 = insertionSortInvoke<h64>;
        f128 = insertionSortInvoke<h128>;
        f256 = insertionSortInvoke<h256>;
        f512 = insertionSortInvoke<h512>;
        f1024Max = insertionSortInvoke<h1024Max>;
        driver();
    }

    void mergeSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Merge Sort";
        f2 = mergeSortInvoke<h2>;
        f4 = mergeSortInvoke<h4>;
        f8 = mergeSortInvoke<h8>;
        f16 = mergeSortInvoke<h16>;
        f32 = mergeSortInvoke<h32>;
        f64 = mergeSortInvoke<h64>;
        f128 = mergeSortInvoke<h128>;
        f256 = mergeSortInvoke<h256>;
        f512 = mergeSortInvoke<h512>;
        f1024Max = mergeSortInvoke<h1024Max>;
        driver();
    }

    void quickSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        sortType = "Quick Sort";
        f2 = quickSortInvoke<h2>;
        f4 = quickSortInvoke<h4>;
        f8 = quickSortInvoke<h8>;
        f16 = quickSortInvoke<h16>;
        f32 = quickSortInvoke<h32>;
        f64 = quickSortInvoke<h64>;
        f128 = quickSortInvoke<h128>;
        f256 = quickSortInvoke<h256>;
        f512 = quickSortInvoke<h512>;
        f1024Max = quickSortInvoke<h1024Max>;
        driver();
    }

    void stlSort()
    {
        // can't increase lengths on these dynamically, requires separate types and expansions (sigh)
        throw Not_Working_Yet();
        sortType = "STL Sort";
        f2 = stlSortInvoke<h2>;
        f4 = stlSortInvoke<h4>;
        f8 = stlSortInvoke<h8>;
        f16 = stlSortInvoke<h16>;
        f32 = stlSortInvoke<h32>;
        f64 = stlSortInvoke<h64>;
        f128 = stlSortInvoke<h128>;
        f256 = stlSortInvoke<h256>;
        f512 = stlSortInvoke<h512>;
        f1024Max = stlSortInvoke<h1024Max>;
        driver();
    }
};

int main()
{
    cout << endl << endl << "Three different string types, identical in content and" << endl
         << "sorting logic, but not in timings." << endl << endl
         << "[Note: Remember to set the C++11 switch in the IDE or compiler!" << endl << endl
         << " Remember to use release builds if you are analyzing performance," << endl
         << "   otherwise Symbionts will be very slow!" << endl << endl
         << " Remember to set the \"ulimit -s\" soft and hard stack limits to unlimited," <<endl
         << "   otherwise it can die!]" << endl;

    SortBench m;
    m.initializeVars(16, 65536, 5); // initial array size, doubling maximum, and iterations per size (precision)
    try
    {
        /*
        Numeric<int> numericsSS;
        numericsSS.selectionSort(0, 10000000); // min, max of random generation

        Numeric<long> numericsSH;
        numericsSH.shellSort(0, 10000000); // min, max of random generation

        Numeric<long long> numericsIS;
        numericsIS.insertionSort(0, 10000000); // min, max of random generation

        Numeric<short> numericsQS;
        numericsQS.quickSort(0, 10000); // min, max of random generation

        Numeric<double> numericsMS;
        numericsMS.mergeSort(0.0, 10000000.0); // min, max of random generation
        */
        DString<char> dstringsQS;
        dstringsQS.quickSort();

        DString<char> dstringsMS;
        dstringsMS.mergeSort();

        Hybrid hstringsQS;
        hstringsQS.quickSort();

        Hybrid hstringsMS;
        hstringsMS.mergeSort();

        Isolate istringsQS;
        istringsQS.quickSort();

        Isolate istringsMS;
        istringsMS.mergeSort();

        PString<string> pstringsQS;
        pstringsQS.quickSort(2, 1024); // initial, maximum string length by doubling

        PString<string> pstringsMS;
        pstringsMS.mergeSort(2, 1024); // initial, maximum string length by doubling
	
	cout << endl;

    }
    catch (...)
    {
        std::exception_ptr p = std::current_exception();
        cerr << "Exception: "
             << (p ?
                 p.__cxa_exception_type()->name() :
                 "Anonymous")
             << endl;
    }
    return 0;
}
