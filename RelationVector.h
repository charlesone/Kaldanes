#ifndef RELATIONVECTOR_H
#define RELATIONVECTOR_H

/*
    [Valverde Computing copyright notice]

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    As an exception, the copyright holders of this Library grant you permission to
    (i) compile an Application with the Library, and
    (ii) distribute the Application containing code generated by the Library and
    added to the Application during this compilation process under terms of your choice,
    provided you also meet the terms and conditions of the Application license.

RelationVector.h - header file for a database relation using indexes with a directional component
  for automatic optimization. RelationVector class holds a from column and a to column as
  IndexString class objects.

  In an SQL language query that joins tables, the connections between tables are reflected in a
  where clause or a join statement with foreign keys such as:

	SELECT table1.column1, table2.column4, table1.column3
	FROM table1
	WHERE table1.column3 = table2.column7;
	
  Then the offline tools, in particular the SQL compiler and optimizer, make informed choices as
  to what that statement means at runtime. For more complex joins, there might be no connection
  between the parts of the join: for example, two sets of where clauses of four completely
  separate tables will have no linkage for the compiler to generate a query from: that will
  generate an SQL error, unless there is some rule to rectify it.

  In the relational database system presented in the current code base, it was decided to use
  RelationVector items as template parameters, which contain (from-column, to-column) IndexString
  pairs on one or two tables with a vectored direction, and the order of those relation vectors in
  a set to deduce the join method for that query.

  RelationVector Class Objects Soft-Define JoinedRowStruct Internals

  In processing ordered sets of relation vectors as a join, the first relation vector establishes
  two columns on those one or two tables as a basis, yielding a first from-table and a first
  to-table and then produces a range query linking the first from-column and the first to-column
  introducing a first to-table range context of row values. After that, the connection between
  successive relation vectors defines a range query linking the from-column and the to-column of
  each additional relation vector: that introduces a new to-table range context of row values, and
  potentially new to-tables to the join.

  Hence, the ordered relationship between relation vectors creates a large joined table consisting
  of the first from-table, the first to-table and all successive to-tables from the ordered set of
  relation vectors. This process mirrors the programming by hand of nested-loop equijoins
  precisely, and the top-down nature of nested-loop equijoins guides the creation of the linkage
  rule for them.

  That rule is simple in concept and execution: the from-table in each successive relation vector,
  after the first, must pre-exist in the previous relation vectors as a to-table or a from-table,
  in that order, going in reverse. The code for initializing this (constexpr void initJoin()) is
  relatively simple, only made complex by the nature of variadic template parameter pack rules and
  the recursion methods for termination of recursion making coding more complex.

  As we shall see below, an N-dimensional set of RelationVector types passed as a parameter pack
  into the QueryPlan class and then subsequently into the JoinedRow class, will soft-define, by
  the RelationVector contained types and order, an N+1-dimensional JoinedRowStruct, which is
  produced by the QueryPlan class and becomes the basis of the internal data of the JoinedRow
  class objects in arrays of relational join query output.

  That soft-defined quality means that routines creating or processing any JoinedRowStruct will
  always involve compile time recursion across the parameter pack of RelationVector types passed
  in a parameters to the QueryPlan class and the JoinedRow class. And as complicated as that gets,
  for performance purposes, it’s a very, very, very good thing to have the compiler do the work
  and to banish that overhead cost from the runtime of the user.

  Static Polymorphism Using reinterpret_cast of void Pointers

  Static polymorphism became a necessity for the RelationVector, which contains the “from” and
  “to” IndexString pointers, because those objects don’t exist, except as types, until runtime
  initialization of the relation vector objects from the actual
  dropAnchorCopyKeysSortIndex-created indexes. This makes compiling the various accessing code,
  such as placing a parameter pack of relation vectors into a tuple and then accessing those
  objects in the parameter pack recursion for things like join, problematic.

  The solution was to leave the pointers uninitialized and then in the accessor routines
  fromIndex() and toIndex(), to do a conditional test before returning them, incurring a one
  instruction permanent cost of a register test for zero. If the test fails then the type is used
  in a fixFromPtr() or fixToPtr() procedure via reinterpret_cast of the void pointer stored in a
  static global array at runtime during initialization. [auto arrays would be very useful here,
  were such a thing made legal.] The use of constexpr for those member functions had to be
  abandoned, because constexpr in C++11 discards type information on the pointers being returned
  in both sets of procedures, so inline had to be used.

*/

#include <iostream>
#include "RowString.h"
#include "IndexString.h"
#include <string>
#include <typeinfo>

#ifdef __GNUG__
#include <cxxabi.h> // gcc only: fetching type names
#endif // __GNUG__

using namespace std;

// This is a database relation using indexes with a directional component for automatic optimization.
template <typename fromIndexType, typename toIndexType>
class RelationVector
{
public:
    class Bad_IndexString_Anchor : public runtime_error
    {
    public:
        Bad_IndexString_Anchor() :
            runtime_error("no index, or corrupted index for this column of this table") {}
    };

    struct RelationStruct
    {
        fromIndexType* from;
        toIndexType* to;
    };

    RelationStruct r;

    constexpr void emptyFunc() const
    {
        return;
    };

    inline fromIndexType* fromIndex()
    {
        (r.from != 0) ? emptyFunc() : fixFromPtr();
        return r.from;
    }

    inline toIndexType* toIndex()
    {
        (r.to != 0) ? emptyFunc() : fixToPtr();
        return r.to;
    }

    constexpr static void* testedIndexStringAnchor(void* indexStringAnchor)
    {
        return (indexStringAnchor != 0) ? indexStringAnchor : throw Bad_IndexString_Anchor();
    }

    inline void fixFromPtr()
    {
        r.from = reinterpret_cast<fromIndexType*>(testedIndexStringAnchor(indexAnchors[((fromIndexType*)0)->indexAnchorOff()]));
        return;
    }

    inline void fixToPtr()
    {
        r.to = reinterpret_cast<toIndexType*>(testedIndexStringAnchor(indexAnchors[((toIndexType*)0)->indexAnchorOff()]));
        return;
    }

    // prints the metadata
    friend ostream& operator<< (ostream &os, const RelationVector& rhs)
    {
        os << rhs.fromIndex() << endl << rhs.toIndex() << endl;
        return os;
    }

};

#endif // RELATIONVECTOR_H
